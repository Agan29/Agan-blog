<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue | AGAN</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/Agan-blog/img/favicon.ico">
    <meta name="description" content="悠悠的古城中 听美人奏琴声,长枪刺破云霞 放下一生牵挂,舍命奉陪 抵不过天公不作美,遇见即是上上签 纵使结局不如意">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    
    <link rel="preload" href="/Agan-blog/assets/css/0.styles.1674594c.css" as="style"><link rel="preload" href="/Agan-blog/assets/js/app.3c2129f2.js" as="script"><link rel="preload" href="/Agan-blog/assets/js/2.0d86c6dd.js" as="script"><link rel="preload" href="/Agan-blog/assets/js/55.49595207.js" as="script"><link rel="prefetch" href="/Agan-blog/assets/js/10.7078a18d.js"><link rel="prefetch" href="/Agan-blog/assets/js/11.d88f4ce5.js"><link rel="prefetch" href="/Agan-blog/assets/js/12.9421e68f.js"><link rel="prefetch" href="/Agan-blog/assets/js/13.3a1a129a.js"><link rel="prefetch" href="/Agan-blog/assets/js/14.5937ebf2.js"><link rel="prefetch" href="/Agan-blog/assets/js/15.4936127b.js"><link rel="prefetch" href="/Agan-blog/assets/js/16.12136193.js"><link rel="prefetch" href="/Agan-blog/assets/js/17.86fdf534.js"><link rel="prefetch" href="/Agan-blog/assets/js/18.b8319bf1.js"><link rel="prefetch" href="/Agan-blog/assets/js/19.9752074d.js"><link rel="prefetch" href="/Agan-blog/assets/js/20.5410609d.js"><link rel="prefetch" href="/Agan-blog/assets/js/21.49488984.js"><link rel="prefetch" href="/Agan-blog/assets/js/22.b60a0706.js"><link rel="prefetch" href="/Agan-blog/assets/js/23.898fc863.js"><link rel="prefetch" href="/Agan-blog/assets/js/24.fda9bf26.js"><link rel="prefetch" href="/Agan-blog/assets/js/25.895b4cba.js"><link rel="prefetch" href="/Agan-blog/assets/js/26.8dac8683.js"><link rel="prefetch" href="/Agan-blog/assets/js/27.683d24dd.js"><link rel="prefetch" href="/Agan-blog/assets/js/28.efd2334c.js"><link rel="prefetch" href="/Agan-blog/assets/js/29.e77fea17.js"><link rel="prefetch" href="/Agan-blog/assets/js/3.1a398d3a.js"><link rel="prefetch" href="/Agan-blog/assets/js/30.561fc879.js"><link rel="prefetch" href="/Agan-blog/assets/js/31.a4b0f822.js"><link rel="prefetch" href="/Agan-blog/assets/js/32.140f8495.js"><link rel="prefetch" href="/Agan-blog/assets/js/33.078f355e.js"><link rel="prefetch" href="/Agan-blog/assets/js/34.7921c113.js"><link rel="prefetch" href="/Agan-blog/assets/js/35.85b6395d.js"><link rel="prefetch" href="/Agan-blog/assets/js/36.56a6bc9a.js"><link rel="prefetch" href="/Agan-blog/assets/js/37.f94705be.js"><link rel="prefetch" href="/Agan-blog/assets/js/38.ede5f11d.js"><link rel="prefetch" href="/Agan-blog/assets/js/39.440a48e8.js"><link rel="prefetch" href="/Agan-blog/assets/js/4.722a81fa.js"><link rel="prefetch" href="/Agan-blog/assets/js/40.59b0244b.js"><link rel="prefetch" href="/Agan-blog/assets/js/41.c5c79df1.js"><link rel="prefetch" href="/Agan-blog/assets/js/42.b32cc047.js"><link rel="prefetch" href="/Agan-blog/assets/js/43.dcf4204c.js"><link rel="prefetch" href="/Agan-blog/assets/js/44.c3669e78.js"><link rel="prefetch" href="/Agan-blog/assets/js/45.b8c83895.js"><link rel="prefetch" href="/Agan-blog/assets/js/46.d5e11c38.js"><link rel="prefetch" href="/Agan-blog/assets/js/47.6e8e6a17.js"><link rel="prefetch" href="/Agan-blog/assets/js/48.5feb8558.js"><link rel="prefetch" href="/Agan-blog/assets/js/49.0f23f936.js"><link rel="prefetch" href="/Agan-blog/assets/js/5.e1e9fbee.js"><link rel="prefetch" href="/Agan-blog/assets/js/50.3817003e.js"><link rel="prefetch" href="/Agan-blog/assets/js/51.947892ad.js"><link rel="prefetch" href="/Agan-blog/assets/js/52.b3d8699f.js"><link rel="prefetch" href="/Agan-blog/assets/js/53.a56229c5.js"><link rel="prefetch" href="/Agan-blog/assets/js/54.a062f12e.js"><link rel="prefetch" href="/Agan-blog/assets/js/56.7a3249d2.js"><link rel="prefetch" href="/Agan-blog/assets/js/57.6f4387d7.js"><link rel="prefetch" href="/Agan-blog/assets/js/58.0cbc79f7.js"><link rel="prefetch" href="/Agan-blog/assets/js/59.2e2f114c.js"><link rel="prefetch" href="/Agan-blog/assets/js/6.0c2419ec.js"><link rel="prefetch" href="/Agan-blog/assets/js/60.cbae4a83.js"><link rel="prefetch" href="/Agan-blog/assets/js/61.6e70f846.js"><link rel="prefetch" href="/Agan-blog/assets/js/62.f21a405e.js"><link rel="prefetch" href="/Agan-blog/assets/js/63.db589b0d.js"><link rel="prefetch" href="/Agan-blog/assets/js/64.1f95cef9.js"><link rel="prefetch" href="/Agan-blog/assets/js/65.f1408ec1.js"><link rel="prefetch" href="/Agan-blog/assets/js/66.e713aa05.js"><link rel="prefetch" href="/Agan-blog/assets/js/67.3c617fa4.js"><link rel="prefetch" href="/Agan-blog/assets/js/68.d21e34d6.js"><link rel="prefetch" href="/Agan-blog/assets/js/69.31b24de4.js"><link rel="prefetch" href="/Agan-blog/assets/js/7.accc422d.js"><link rel="prefetch" href="/Agan-blog/assets/js/70.cd4f2a03.js"><link rel="prefetch" href="/Agan-blog/assets/js/71.89266fef.js"><link rel="prefetch" href="/Agan-blog/assets/js/72.3307e935.js"><link rel="prefetch" href="/Agan-blog/assets/js/73.5b1aedd1.js"><link rel="prefetch" href="/Agan-blog/assets/js/74.c578d90d.js"><link rel="prefetch" href="/Agan-blog/assets/js/75.65c4c504.js"><link rel="prefetch" href="/Agan-blog/assets/js/76.563a3e33.js"><link rel="prefetch" href="/Agan-blog/assets/js/77.9a401ea8.js"><link rel="prefetch" href="/Agan-blog/assets/js/78.8968edd9.js"><link rel="prefetch" href="/Agan-blog/assets/js/79.e6bc297c.js"><link rel="prefetch" href="/Agan-blog/assets/js/8.977aa7f9.js"><link rel="prefetch" href="/Agan-blog/assets/js/80.803f5cd2.js"><link rel="prefetch" href="/Agan-blog/assets/js/81.0344aa07.js"><link rel="prefetch" href="/Agan-blog/assets/js/82.e830d944.js"><link rel="prefetch" href="/Agan-blog/assets/js/83.9c7bd0a3.js"><link rel="prefetch" href="/Agan-blog/assets/js/84.1d3691d3.js"><link rel="prefetch" href="/Agan-blog/assets/js/85.d0e0eec9.js"><link rel="prefetch" href="/Agan-blog/assets/js/86.7a9b98f1.js"><link rel="prefetch" href="/Agan-blog/assets/js/87.989e4a6a.js"><link rel="prefetch" href="/Agan-blog/assets/js/88.96fb2e84.js"><link rel="prefetch" href="/Agan-blog/assets/js/89.63cf36b0.js"><link rel="prefetch" href="/Agan-blog/assets/js/9.55a60885.js"><link rel="prefetch" href="/Agan-blog/assets/js/90.19849981.js"><link rel="prefetch" href="/Agan-blog/assets/js/91.950b7c76.js"><link rel="prefetch" href="/Agan-blog/assets/js/92.5c148052.js"><link rel="prefetch" href="/Agan-blog/assets/js/93.e926e177.js">
    <link rel="stylesheet" href="/Agan-blog/assets/css/0.styles.1674594c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="ag-container is-page" data-v-1895eed2><div class="ag-header" data-v-312fb2c6 data-v-1895eed2><nav class="ag-nav" data-v-312fb2c6><span data-v-312fb2c6><a href="/Agan-blog/" class="router-link-active" data-v-312fb2c6>首页</a></span><span data-v-312fb2c6><a href="/Agan-blog/pages/d67b9d/" data-v-312fb2c6>设计</a></span><span data-v-312fb2c6><a href="/Agan-blog/pages/8143cc480faf9a11/" data-v-312fb2c6>前端</a></span><span data-v-312fb2c6><a href="/Agan-blog/pages/fe171a/" data-v-312fb2c6>随笔</a></span><span data-v-312fb2c6><a href="/Agan-blog/pages/beb6c0bd8a66cea6" data-v-312fb2c6>收藏夹</a></span><span data-v-312fb2c6><a data-v-312fb2c6>
          其他
          </a></span></nav> <div class="ag-toggle-mode theme-mode" data-v-704e114c data-v-312fb2c6><div class="current-mode" data-v-704e114c>
    自动
  </div> <ul class="select-mode" style="display:none;" data-v-704e114c><li class="light" data-v-704e114c>
      浅色
    </li><li class="dark" data-v-704e114c>
      暗色
    </li><li class="is-active auto" data-v-704e114c>
      自动
    </li></ul></div></div> <div class="ag-body" data-v-1895eed2><div class="ag-slogn" data-v-92e64100 data-v-1895eed2><h1 data-v-92e64100></h1> <h4 data-v-92e64100></h4></div> <div class="ag-page" data-v-a14a39de data-v-1895eed2 data-v-1895eed2><div class="ag-slide-panel ag-side" data-v-302c62e6 data-v-a14a39de><div class="slide-item" data-v-302c62e6><div class="slide-group" data-v-b37a5190 data-v-302c62e6><div class="slide-title" data-v-b37a5190>
      计算机相关
    </div> <ul class="slide-menus" style="display:none;" data-v-b37a5190 data-v-b37a5190><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/772077/" data-v-b37a5190>计算机浏览器相关
              </a></div></li><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/014c11/" data-v-b37a5190>在输入URL之后，浏览器上做了什么
              </a></div></li><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/392a60/" data-v-b37a5190>「前端进阶必备」深入理解现代浏览器
              </a></div></li><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/0ae1a6/" data-v-b37a5190> 重排重绘为什么会影响渲染，如何避免
              </a></div></li><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/450cf0/" data-v-b37a5190>js css 顺序对前端优化影响
              </a></div></li><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/12cf5b/" data-v-b37a5190> 缓存机制
              </a></div></li><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/4cde03/" data-v-b37a5190>HTTP, HTTPS, HTTP2 的区别和联系
              </a></div></li><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/3fb3b0/" data-v-b37a5190>跨域问题
              </a></div></li><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/0d4c51/" data-v-b37a5190>事件循环
              </a></div></li></ul></div></div><div class="slide-item" data-v-302c62e6><div class="slide-group" data-v-b37a5190 data-v-302c62e6><div class="slide-title" data-v-b37a5190>
      HTML
    </div> <ul class="slide-menus" style="display:none;" data-v-b37a5190 data-v-b37a5190><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/17f79a/" data-v-b37a5190> Html
              </a></div></li></ul></div></div><div class="slide-item" data-v-302c62e6><div class="slide-group" data-v-b37a5190 data-v-302c62e6><div class="slide-title" data-v-b37a5190>
      CSS
    </div> <ul class="slide-menus" style="display:none;" data-v-b37a5190 data-v-b37a5190><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/2cf44b/" data-v-b37a5190> CSS
              </a></div></li></ul></div></div><div class="slide-item" data-v-302c62e6><div class="slide-group" data-v-b37a5190 data-v-302c62e6><div class="slide-title" data-v-b37a5190>
      JS
    </div> <ul class="slide-menus" style="display:none;" data-v-b37a5190 data-v-b37a5190><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/85e0ff/" data-v-b37a5190> Js
              </a></div></li></ul></div></div><div class="slide-item" data-v-302c62e6><div class="slide-group" data-v-b37a5190 data-v-302c62e6><div class="slide-title" data-v-b37a5190>
      框架
    </div> <ul class="slide-menus" style="display:none;" data-v-b37a5190 data-v-b37a5190><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/07183b/" data-v-b37a5190> Webpack
              </a></div></li><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/4a6389/" aria-current="page" class="router-link-exact-active router-link-active" data-v-b37a5190> Vue
              </a></div></li><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/bafb86/" data-v-b37a5190> React
              </a></div></li></ul></div></div><div class="slide-item" data-v-302c62e6><div class="slide-group" data-v-b37a5190 data-v-302c62e6><div class="slide-title" data-v-b37a5190>
      Node
    </div> <ul class="slide-menus" style="display:none;" data-v-b37a5190 data-v-b37a5190><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/c2c1d1/" data-v-b37a5190> Node
              </a></div></li></ul></div></div><div class="slide-item" data-v-302c62e6><div class="slide-link" data-v-b37a5190 data-v-302c62e6><a href="/Agan-blog/pages/c15f88/" data-v-b37a5190>性能优化
              </a></div></div><div class="slide-item" data-v-302c62e6><div class="slide-group" data-v-b37a5190 data-v-302c62e6><div class="slide-title" data-v-b37a5190>
      算法
    </div> <ul class="slide-menus" style="display:none;" data-v-b37a5190 data-v-b37a5190><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/6f88c1/" data-v-b37a5190> 算法
              </a></div></li></ul></div></div><div class="slide-item" data-v-302c62e6><div class="slide-link" data-v-b37a5190 data-v-302c62e6><a href="/Agan-blog/pages/7d2fc9/" data-v-b37a5190>一些概念
              </a></div></div></div> <div class="ag-main" data-v-a14a39de><div class="ag-content" data-v-a14a39de><div class="content__default" data-v-a14a39de data-v-a14a39de><h1 id="vue"><a href="#vue" class="header-anchor">#</a> Vue</h1> <p>[TOC]</p> <h2 id="_1-vue-的生命周期"><a href="#_1-vue-的生命周期" class="header-anchor">#</a> 1 Vue 的生命周期</h2> <h3 id="_1-1-单个组件的生命周期"><a href="#_1-1-单个组件的生命周期" class="header-anchor">#</a> 1.1 单个组件的生命周期</h3> <p>按创建，激活到更新，停止, 最后销毁的顺序。</p> <ol><li>beforeCreated:</li> <li>created</li> <li>beforeMounted</li> <li>mounted</li> <li>activated</li> <li>beforeUpdated</li> <li>updated</li> <li>deactivated</li> <li>beforeDestory</li> <li>destoryed</li></ol> <p>如果有两行代码同时进行了停止和更新，无论代码顺序，生命周期的顺序都将是 deactivated -&gt; beforeUpdate -&gt; updated</p> <p>其他：</p> <ul><li>错误捕获 errorCaptured 错误捕获</li></ul> <h3 id="_1-2-父子组件的生命周期顺序"><a href="#_1-2-父子组件的生命周期顺序" class="header-anchor">#</a> 1.2 父子组件的生命周期顺序</h3> <p>父 beforeCreated -&gt; 父 created -&gt; 父 beforeMounted -&gt; 子 beforeCreated -&gt; 子 created -&gt; 子 beforeMounted -&gt; 子 mounted -&gt; 父 mounted</p> <p>接着是下面的三种情况：</p> <ul><li>更新：
<ul><li>只更新父或子: 局部更新，父或子 beforeUpdate -&gt; updated</li> <li>同时更新父和子: 父 beforeUpdate -&gt; 子 beforeUpdate -&gt; 子 updated -&gt; 父 updated</li></ul></li> <li>销毁父组件</li></ul> <p>父 beforeDestroy -&gt; 子 beforeDestroy -&gt; 子 destroyed -&gt; 父 destroyed</p> <ul><li>激活父组件</li></ul> <p>子 activated -&gt; 父 activated -&gt; 停止 -&gt; 子 deactivated -&gt; 父 deactivated</p> <h2 id="_2-响应式原理"><a href="#_2-响应式原理" class="header-anchor">#</a> 2 响应式原理</h2> <p>使用 defineReactive 函数将深度遍历一个对象（或循环遍历数组），将对象构建成响应式式对象。 明显的标志就是 <strong>ob</strong> 属性 实质是通过 Object.defineProperty 对属性（深度遍历）进行 setter 和 getter 拦截。</p> <ul><li>get 中主要做依赖收集 dep.depend() 【子属性也收集该依赖】</li> <li>set 中主要做派发更新 （新的值才更新） dep.notify() 调用 dep 数组中每个渲染 watcher 的 update 方法更新 DOM</li></ul> <blockquote><p>源码路径：src/core/observer/index.js</p></blockquote> <h3 id="_2-1-响应式对象使用应该注意哪些点"><a href="#_2-1-响应式对象使用应该注意哪些点" class="header-anchor">#</a> 2.1 响应式对象使用应该注意哪些点</h3> <ul><li>对象的新增属性，数组的新增元素，因为不是响应式的，所以不会触发视图渲染。 此时应该使用 $set</li> <li>改变某一下标的元素，因为 Vue 未实现监听，所以不会触发视图渲染。 此时应该使用 $set</li> <li>删除对象的属性，数组下标的某一元素，确保删除属性能触发视图渲染。此时应该使用 $delete</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">$set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">[</span>index <span class="token operator">|</span> property<span class="token punctuation">]</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
$<span class="token keyword">delete</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">[</span>index <span class="token operator">|</span> property<span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="_3-v-model-基本原理"><a href="#_3-v-model-基本原理" class="header-anchor">#</a> 3 v-model 基本原理</h2> <ol><li>首先在编译阶段，v-model 被当成普通指令解析到 el.directives，然后在解析 v-model 的时候，会根据节点的不同请求去执行不同的逻辑。
<ul><li>如果节点是 select、checkbox, radio，则监听的是 change 事件</li> <li>如果节点是 input，textarea，则监听一般是 input 事件，在.lazy 下的情况下是 change 事件。</li> <li>如果节点是组件，则是使用自定义的回调函数</li></ul></li> <li>在运行的时候，通过相应事件的监听函数去更改数据。</li></ol> <p>v-model 实质是一种语法糖，换成模板写法如下：</p> <div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">:value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>sth<span class="token punctuation">&quot;</span></span> <span class="token attr-name">@input</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>sth = $event.target.value<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
</code></pre></div><blockquote><p>源码路径 src/platforms/web/compiler/directives/model.js</p></blockquote> <h3 id="_3-1-组件中使用-v-model"><a href="#_3-1-组件中使用-v-model" class="header-anchor">#</a> 3.1 组件中使用 v-model</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  model<span class="token operator">:</span> <span class="token punctuation">{</span>
    prop<span class="token operator">:</span> <span class="token string">'num'</span><span class="token punctuation">,</span> <span class="token comment">// 自定义属性名</span>
    event<span class="token operator">:</span> <span class="token string">'addNum'</span><span class="token punctuation">,</span> <span class="token comment">// 自定义事件名</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  props<span class="token operator">:</span> <span class="token punctuation">{</span>
    num<span class="token operator">:</span> Number<span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  methods<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">$emit</span><span class="token punctuation">(</span><span class="token string">'addNum'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>num <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_3-2-vue2-0-响应式的缺陷"><a href="#_3-2-vue2-0-响应式的缺陷" class="header-anchor">#</a> 3.2 vue2.0 响应式的缺陷</h3> <ul><li>Object.defineProperty 无法监控到数组下标的变化，导致通过数组下标添加元素，不能实时响应；</li></ul> <p>Object.defineProperty 本身是可以监控到数组下标的变化的，但是在 Vue 中，从性能/体验的性价比考虑，尤大大就弃用了这个特性。具体我们可以参考 《记一次思否问答的问题思考：Vue 为什么不能检测数组变动》这篇文章。简单说就是假设元素内容只有 4 个有意义的值，但是长度确实 1000，我们不可能为 1000 个元素做检测操作。</p> <ul><li>Object.defineProperty 只能劫持对象的属性，从而需要对每个对象，每个属性进行遍历，如果，属性值是对象，还需要深度遍历。</li></ul> <h3 id="_3-3-vue3-0-为什么使用-proxy-实现响应式"><a href="#_3-3-vue3-0-为什么使用-proxy-实现响应式" class="header-anchor">#</a> 3.3 vue3.0 为什么使用 Proxy 实现响应式</h3> <p>Vue3.0 的响应式 Proxy</p> <ul><li>Proxy 可以劫持整个对象，并返回一个新的对象。</li> <li>Proxy 不仅可以代理对象，还可以代理数组。还可以代理动态增加的属性。</li></ul> <h2 id="_4-vue-中通信方式"><a href="#_4-vue-中通信方式" class="header-anchor">#</a> 4 vue 中通信方式</h2> <ul><li>props 和 $emit</li> <li>$parent 和 $children</li> <li>ref 和 refs</li> <li>$attr 和 $listener: v-bind=&quot;$attrs&quot; v-on=&quot;$listeners&quot;</li> <li>provide 和 inject: 实质就是递归父组件帮你寻找对应的 provider<br>
provide 和 inject 绑定并不是可响应的。这是刻意为之的。然而，如果你传入了一个可监听的对象，那么其对象的属性还是可响应的。</li> <li>vueBus: 中央事务总线，一个发布订阅中心</li> <li>vuex：状态树管理</li></ul> <h2 id="_5-nexttick-的原理"><a href="#_5-nexttick-的原理" class="header-anchor">#</a> 5 nextTick 的原理</h2> <ul><li>Vue.nextTick 是在执行 render 渲染后运行的，即在 render 渲染后的下一次 tick（event loop 最开始的时候执行）</li> <li>Vue.nextTikc 的降级顺序（优先使用） Promise.then(microtask) , MutationObserver(microtask) , setImmediate(task) , setTimeout(fn, 0)(task)</li></ul> <blockquote><p>源码路径 src/core/util/next-tick.js</p></blockquote> <h2 id="_6-new-vue-会做什么操作"><a href="#_6-new-vue-会做什么操作" class="header-anchor">#</a> 6 new Vue 会做什么操作</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">_init</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">options</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> vm <span class="token operator">=</span> <span class="token keyword">this</span>
    <span class="token comment">// ...忽略，从第45行看起</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>process<span class="token punctuation">.</span>env<span class="token punctuation">.</span><span class="token constant">NODE_ENV</span> <span class="token operator">!==</span> <span class="token string">'production'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">initProxy</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// 作用域代理，拦截组件内访问其它组件的数据</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span>_renderProxy <span class="token operator">=</span> vm
    <span class="token punctuation">}</span>
    <span class="token comment">// expose real self</span>
    vm<span class="token punctuation">.</span>_self <span class="token operator">=</span> vm
    <span class="token function">initLifecycle</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// 建立父子组件关系，在当前实例上添加一些属性和生命周期标识。</span>
    <span class="token function">initEvents</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// 用来存放除 @hook:生命周期钩子名称=&quot;绑定的函数&quot;事件的对象。如： $on、 $emit等</span>
    <span class="token function">initRender</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// 用于初始化 $slots、 $attrs、 $listeners</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'beforeCreate'</span><span class="token punctuation">)</span>
    <span class="token function">initInjections</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// resolve injections before data/props  // 初始化 inject，一般用于更深层次的组件通信，相当于加强版子组件的 props。用于组件库开发较多</span>
    <span class="token function">initState</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// 是很多选项初始化的汇总，包括： props、methods、data、computed和watch 等。</span>
    <span class="token function">initProvide</span><span class="token punctuation">(</span>vm<span class="token punctuation">)</span> <span class="token comment">// resolve provide after data/props   // 初始化 provide</span>
    <span class="token function">callHook</span><span class="token punctuation">(</span>vm<span class="token punctuation">,</span> <span class="token string">'created'</span><span class="token punctuation">)</span>
    <span class="token comment">// ...忽略</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      vm<span class="token punctuation">.</span><span class="token function">$mount</span><span class="token punctuation">(</span>vm<span class="token punctuation">.</span>$options<span class="token punctuation">.</span>el<span class="token punctuation">)</span>  <span class="token comment">// 挂载实例</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><blockquote><p>源码路径 src/core/instance/init.js</p></blockquote> <h2 id="_7-vue-的-diff-原理"><a href="#_7-vue-的-diff-原理" class="header-anchor">#</a> 7 vue 的 diff 原理</h2> <p>主要执行的是 patch 函数。主要流程如下：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">patch</span> <span class="token punctuation">(</span><span class="token parameter">oldVnode<span class="token punctuation">,</span> vnode<span class="token punctuation">,</span> hydrating<span class="token punctuation">,</span> removeOnly</span><span class="token punctuation">)</span>

</code></pre></div><ol><li>如果 oldVnode 不存在，即是新添加的节点，则创建 vnode 的 DOM</li> <li>如果不是真实的节点且是相同类型的节点，则进入结点 diff，即 patchVnode 函数。否则会用新的节点替换老的。这里的相同类型指的是具有相同的 key 值和一些其他条件，例如标签相同等等</li> <li>如果 oldVnode === vnode，则认为没有变化 如果 oldVnode 的 isAsyncPlaceholder 属性为 true 时，跳过检查异步组件，return；</li> <li>如果 oldVnode 跟 vnode 都是静态节点(实例不会发生变化)，且具有相同的 key，并且当 vnode 是克隆节点或是 v-once 指令控制的节点时，则把 oldVnode.elm 和 oldVnode.child 都复制到 vnode 上；</li> <li>如果 vnode 不是文本节点或注释节点
<ul><li>如果 vnode 和 oldVnode 都有子节点并且两者的子节点不一致时，就调用 updateChildren 更新子节点</li> <li>如果只有 vnode 有子节点，则调用 addVnodes 创建子节点</li> <li>如果只有 oldVnode 有子节点，则调用 removeVnodes 把这些子节点都删除</li> <li>如果 vnode 文本为 undefined，则清空 vnode.elm 文本；</li></ul></li> <li>如果 vnode 是文本节点但是 vnode.text != oldVnode.text 时只需要更新 vnode.elm 的文本内容就可以。</li> <li>在 updateChildren 主要是子节点数组对比,思路是通过首尾两端对比，如果是相同类型的节点也会使用 patchVnode 函数。</li></ol> <p>在做对比中 key 的作用 主要是</p> <ul><li>决定节点是否可以复用</li> <li>建立 key-index 的索引,主要是替代遍历，提升性能</li></ul> <blockquote><p>源码路径 src/core/vdom/patch.js</p></blockquote> <h2 id="_8-computed-和-watcher"><a href="#_8-computed-和-watcher" class="header-anchor">#</a> 8 computed 和 watcher</h2> <h3 id="_8-1-对比"><a href="#_8-1-对比" class="header-anchor">#</a> 8.1 对比</h3> <ul><li>computed 是计算属性，依赖其他属性计算，并且 computed 的值有缓存，只有当计算值发生变化才会返回内容。适合简单的逻辑。</li></ul> <p><strong>注意</strong> computed 里无法使用非纯函数来响应，例如 Date.now()</p> <ul><li>watch 主要用于监控 vue 实例的变化，它监控的变量当然必须在 data 里面声明才可以，它可以监控一个变量，也可以是一个对象。比较适合的场景是一个数据影响多个数据。</li> <li>watch 支持异步。</li></ul> <h3 id="_8-2-watcher-的分类"><a href="#_8-2-watcher-的分类" class="header-anchor">#</a> 8.2 watcher 的分类</h3> <ul><li>内部-watcher vue 组件上的每一条数据绑定指令(例如)和 computed 属性，通过 compile 最后都会生成一个对应的 watcher 对象。</li> <li>user--watcher 在 watch 属性中，由用户自己定义的，都属于这种类型，即只要监听的属性改变了，都会触发定义好的回调函数</li> <li>render-watcher 每一个组件都会有一个 render-watcher, function () {vm._update(vm._render(), hydrating);}, 当 data / computed 中的属性改变的时候，会调用该 render-watcher 来更新组件的视图</li></ul> <p>watcher 也有固定的执行顺序，分别是: 内部-watcher -&gt; user-watcher -&gt; render-watcher</p> <h2 id="_9-vue-指令"><a href="#_9-vue-指令" class="header-anchor">#</a> 9 Vue 指令</h2> <h3 id="_9-1-全局指令和局部指令"><a href="#_9-1-全局指令和局部指令" class="header-anchor">#</a> 9.1 全局指令和局部指令</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 全局</span>
Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'my-click'</span><span class="token punctuation">,</span> config）

<span class="token comment">// 局部</span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    directives<span class="token operator">:</span><span class="token punctuation">{</span>
        focus<span class="token operator">:</span> config <span class="token comment">// v-focus</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><h3 id="_9-2-配置参数"><a href="#_9-2-配置参数" class="header-anchor">#</a> 9.2 配置参数</h3> <p>一个指令定义对象可以提供如下几个钩子函数 (均为可选)：</p> <ul><li>bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</li> <li>inserted：被绑定元素插入父节点时调用 (仅保证父节点存在，但不一定已被插入文档中)。</li> <li>update：所在组件的 VNode 更新时调用，但是可能发生在其子 VNode 更新之前。指令的值可能发生了改变，也可能没有。但是你可以通过比较更新前后的值来忽略不必要的模板更新。</li> <li>componentUpdated：指令所在组件的 VNode 及其子 VNode 全部更新后调用。</li> <li>unbind：只调用一次，指令与元素解绑时调用。</li></ul> <p>每个钩子函数都有四个参数 el、binding、vnode 和 oldVnode</p> <h2 id="_10-mixin"><a href="#_10-mixin" class="header-anchor">#</a> 10 mixin</h2> <p>混入 (mixin) 提供了一种非常灵活的方式，来分发 Vue 组件中的可复用功能。</p> <p>全局和局部 mixin</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> mixin <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function-variable function">data</span><span class="token operator">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      message<span class="token operator">:</span> <span class="token string">'hello'</span><span class="token punctuation">,</span>
      foo<span class="token operator">:</span> <span class="token string">'abc'</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
<span class="token comment">//全局mixin</span>
Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span>mixin<span class="token punctuation">)</span>
<span class="token comment">//局部mixin</span>
<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  mixins<span class="token operator">:</span> <span class="token punctuation">[</span>mixin<span class="token punctuation">]</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>合并策略</p> <ul><li>钩子函数将合并成数组，且混入的函数先执行</li> <li>其他的值为对象的将被合并为同一个对象。两个对象键名冲突时，取组件对象的键值对。</li> <li>默认的合并策略可以使用下面的方面更改</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span>config<span class="token punctuation">.</span>optionMergeStrategies<span class="token punctuation">.</span><span class="token function-variable function">myOption</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">toVal<span class="token punctuation">,</span> fromVal</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 返回合并后的值</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_11-vue-router"><a href="#_11-vue-router" class="header-anchor">#</a> 11 vue-router</h2> <h3 id="_11-1-路由模式"><a href="#_11-1-路由模式" class="header-anchor">#</a> 11.1 路由模式</h3> <ul><li>HashHistory 模式：实质是监听 onhashchange 事件 （window.location API - location.hash）</li> <li>HTML5History 模式：实质是使用 h5 的 window.history API, 监听 popstate 事件（pushState, replaceState）。<em><strong>使用该模式，服务器和前端需要做好页面 404 的处理</strong></em></li> <li>AbstractHistory 模式：在不支持上面两种方式的环境下使用，如 node 环境，实际是使用数组模拟路由历史栈</li></ul> <blockquote><p>源码： src/history 目录下的 js 文件</p></blockquote> <h3 id="_11-2-导航守卫"><a href="#_11-2-导航守卫" class="header-anchor">#</a> 11.2 导航守卫</h3> <ul><li>全局守卫</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>router<span class="token punctuation">.</span><span class="token function">beforeEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
router<span class="token punctuation">.</span><span class="token function">afterEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
router<span class="token punctuation">.</span><span class="token function">beforeResolve</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span></span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment">// 与afterEach类似, 区别是在导航被确认之前，同时在所有组件内守卫和异步路由组件被解析之后，解析守卫就被调用</span>
</code></pre></div><ul><li>路由独享守卫</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> router <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">VueRouter</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  routes<span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token punctuation">{</span>
      path<span class="token operator">:</span> <span class="token string">'/foo'</span><span class="token punctuation">,</span>
      component<span class="token operator">:</span> Foo<span class="token punctuation">,</span>
      <span class="token function-variable function">beforeEnter</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
      <span class="token operator">...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><ul><li>组件内守卫</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> Foo <span class="token operator">=</span> <span class="token punctuation">{</span>
  template<span class="token operator">:</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">...</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span>
  <span class="token function">beforeRouteEnter</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在渲染该组件的对应路由被 confirm 前调用</span>
    <span class="token comment">// 不！能！获取组件实例 `this`</span>
    <span class="token comment">// 因为当守卫执行前，组件实例还没被创建</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">beforeRouteUpdate</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 在当前路由改变，但是该组件被复用时调用</span>
    <span class="token comment">// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span>
    <span class="token comment">// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span>
    <span class="token comment">// 可以访问组件实例 `this`</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token function">beforeRouteLeave</span><span class="token punctuation">(</span><span class="token parameter">to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> next</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 导航离开该组件的对应路由时调用</span>
    <span class="token comment">// 可以访问组件实例 `this`</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_11-3-vue-router-如何注入"><a href="#_11-3-vue-router-如何注入" class="header-anchor">#</a> 11.3 vue-router 如何注入</h3> <ul><li>基于 vue 的插件机制，全局混入 beforeCreated 和 destroyed 的生命钩子</li> <li>查找根实例上的 route，注入到每个组件上，监听 current 变化</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span>util<span class="token punctuation">.</span><span class="token function">defineReactive</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">'_route'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_router<span class="token punctuation">.</span>history<span class="token punctuation">.</span>current<span class="token punctuation">)</span>
</code></pre></div><ul><li>vue 原型上添加两个属性<img src="https://juejin.im/equation?tex=router%E5%92%8C" alt="router和">route, 拦截 get 操作，限制 set 操作</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token class-name">Vue</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">'$router'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_routerRoot<span class="token punctuation">.</span>_router
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>注册全局组件 RouterView 和 RouterLink</li></ul> <blockquote><p>源码 src/install.js</p></blockquote> <h2 id="_12-vuex"><a href="#_12-vuex" class="header-anchor">#</a> 12 vuex</h2> <h3 id="_12-1-核心概念"><a href="#_12-1-核心概念" class="header-anchor">#</a> 12.1 核心概念</h3> <ul><li>state 数据</li> <li>getter 可看成数据的计算属性</li> <li>mutation 唯一更改数据的方法 通过 store.commit 使用相应的 mutation 方法</li> <li>Action 支持异步的提交 mutation 通过 store.dispatch 使用相应的 Action 方法</li> <li>module 数据分模块。如 moduleA.xx</li></ul> <p><em><strong>数据流</strong></em> 来自官网的图：</p> <p><img src="https://gitee.com/zukunft/MDImage/raw/master/img/20200902003537.png" alt="vuex"></p> <h3 id="_12-2-如何注入"><a href="#_12-2-如何注入" class="header-anchor">#</a> 12.2 如何注入</h3> <p>在使用 Vue.use(vuex) 的时候会执行 install 方法在（vue 插件机制）。这个方法会混入一个 minxin</p> <div class="language-js extra-class"><pre class="language-js"><code>Vue<span class="token punctuation">.</span><span class="token function">mixin</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  <span class="token function">beforeCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> options <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$options
    <span class="token comment">// store injection</span>
    <span class="token comment">// 非根组件指向其父组件的$store，使得所有组件的实例，都指向根的store对象</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>store<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$store <span class="token operator">=</span>
        <span class="token keyword">typeof</span> options<span class="token punctuation">.</span>store <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">?</span> options<span class="token punctuation">.</span><span class="token function">store</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> options<span class="token punctuation">.</span>store
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>options<span class="token punctuation">.</span>parent <span class="token operator">&amp;&amp;</span> options<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>$store<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>$store <span class="token operator">=</span> options<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>$store
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><blockquote><p>源码路径 src/mixin.js</p></blockquote> <h3 id="_12-3-如何实现响应式"><a href="#_12-3-如何实现响应式" class="header-anchor">#</a> 12.3 如何实现响应式</h3> <p>通过添加到 data 中实现响应式</p> <div class="language-js extra-class"><pre class="language-js"><code>store<span class="token punctuation">.</span>_vm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    data<span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token operator">?</span>state<span class="token operator">:</span> state
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    computed <span class="token comment">// 这里是store的getter</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

</code></pre></div><blockquote><p>源码路径：src/store.js resetStoreVM 函数</p></blockquote> <h2 id="_13-vue-应用"><a href="#_13-vue-应用" class="header-anchor">#</a> 13 vue 应用</h2> <h3 id="_13-1-实现一个简易的-render-函数"><a href="#_13-1-实现一个简易的-render-函数" class="header-anchor">#</a> 13.1 实现一个简易的 render 函数</h3> <p>实现一个 createElement(A, B, C)函数，使得执行 createElement 后在页面上可生成以下元素</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token string">'div'</span>
<span class="token keyword">const</span> <span class="token constant">B</span> <span class="token operator">=</span> <span class="token punctuation">{</span> id<span class="token operator">:</span> <span class="token string">'div'</span> <span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token constant">C</span> <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> name<span class="token operator">:</span> <span class="token string">'name'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
  <span class="token punctuation">{</span>
    tag<span class="token operator">:</span> <span class="token string">'p'</span><span class="token punctuation">,</span>
    data<span class="token operator">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>
    children<span class="token operator">:</span> <span class="token string">'text'</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span>
<span class="token keyword">let</span> el <span class="token operator">=</span> <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">C</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>el<span class="token punctuation">)</span>
</code></pre></div><div class="language-html extra-class"><pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>div<span class="token punctuation">&quot;</span></span><span class="token punctuation">&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">&quot;</span>name<span class="token punctuation">&quot;</span></span> <span class="token punctuation">/&gt;</span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>text<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>
</code></pre></div><p>解题</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createElement</span><span class="token punctuation">(</span>tag <span class="token operator">=</span> <span class="token string">'div'</span><span class="token punctuation">,</span> data <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> children<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      <span class="token function-variable function">render</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">let</span> el <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span>tag<span class="token punctuation">)</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          el<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> data<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>children<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> children<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          children<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">child</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            child <span class="token operator">=</span> child <span class="token operator">||</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> child <span class="token operator">===</span> <span class="token string">'function'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
              child<span class="token punctuation">.</span>render <span class="token operator">=</span> child
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>child<span class="token punctuation">.</span>render<span class="token punctuation">)</span> <span class="token punctuation">{</span>
              Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> <span class="token function">createElement</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>tag<span class="token punctuation">,</span> child<span class="token punctuation">.</span>data<span class="token punctuation">,</span> child<span class="token punctuation">.</span>children<span class="token punctuation">)</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            el<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>children<span class="token punctuation">)</span><span class="token punctuation">{</span>
          <span class="token keyword">let</span> text <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>children<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
          el<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> el
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>

</code></pre></div></div> <div data-v-a14a39de></div></div></div></div></div> <div cclass="ag-footer-warp" data-v-1895eed2><div class="ag-footer" data-v-3078f227 data-v-1895eed2><div data-v-3078f227>余 年</div> <div class="supporting" data-v-3078f227>-</div> <div class="supporting" data-v-3078f227>距离2022年还剩下  天</div></div></div></div><div class="global-ui"></div></div>
    <script src="/Agan-blog/assets/js/app.3c2129f2.js" defer></script><script src="/Agan-blog/assets/js/2.0d86c6dd.js" defer></script><script src="/Agan-blog/assets/js/55.49595207.js" defer></script>
  </body>
</html>
