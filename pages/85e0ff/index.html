<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Js | AGAN</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/Agan-blog/img/favicon.ico">
    <meta name="description" content="悠悠的古城中 听美人奏琴声,长枪刺破云霞 放下一生牵挂,舍命奉陪 抵不过天公不作美,遇见即是上上签 纵使结局不如意">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    
    <link rel="preload" href="/Agan-blog/assets/css/0.styles.1674594c.css" as="style"><link rel="preload" href="/Agan-blog/assets/js/app.3c2129f2.js" as="script"><link rel="preload" href="/Agan-blog/assets/js/2.0d86c6dd.js" as="script"><link rel="preload" href="/Agan-blog/assets/js/53.a56229c5.js" as="script"><link rel="prefetch" href="/Agan-blog/assets/js/10.7078a18d.js"><link rel="prefetch" href="/Agan-blog/assets/js/11.d88f4ce5.js"><link rel="prefetch" href="/Agan-blog/assets/js/12.9421e68f.js"><link rel="prefetch" href="/Agan-blog/assets/js/13.3a1a129a.js"><link rel="prefetch" href="/Agan-blog/assets/js/14.5937ebf2.js"><link rel="prefetch" href="/Agan-blog/assets/js/15.4936127b.js"><link rel="prefetch" href="/Agan-blog/assets/js/16.12136193.js"><link rel="prefetch" href="/Agan-blog/assets/js/17.86fdf534.js"><link rel="prefetch" href="/Agan-blog/assets/js/18.b8319bf1.js"><link rel="prefetch" href="/Agan-blog/assets/js/19.9752074d.js"><link rel="prefetch" href="/Agan-blog/assets/js/20.5410609d.js"><link rel="prefetch" href="/Agan-blog/assets/js/21.49488984.js"><link rel="prefetch" href="/Agan-blog/assets/js/22.b60a0706.js"><link rel="prefetch" href="/Agan-blog/assets/js/23.898fc863.js"><link rel="prefetch" href="/Agan-blog/assets/js/24.fda9bf26.js"><link rel="prefetch" href="/Agan-blog/assets/js/25.895b4cba.js"><link rel="prefetch" href="/Agan-blog/assets/js/26.8dac8683.js"><link rel="prefetch" href="/Agan-blog/assets/js/27.683d24dd.js"><link rel="prefetch" href="/Agan-blog/assets/js/28.efd2334c.js"><link rel="prefetch" href="/Agan-blog/assets/js/29.e77fea17.js"><link rel="prefetch" href="/Agan-blog/assets/js/3.1a398d3a.js"><link rel="prefetch" href="/Agan-blog/assets/js/30.561fc879.js"><link rel="prefetch" href="/Agan-blog/assets/js/31.a4b0f822.js"><link rel="prefetch" href="/Agan-blog/assets/js/32.140f8495.js"><link rel="prefetch" href="/Agan-blog/assets/js/33.078f355e.js"><link rel="prefetch" href="/Agan-blog/assets/js/34.7921c113.js"><link rel="prefetch" href="/Agan-blog/assets/js/35.85b6395d.js"><link rel="prefetch" href="/Agan-blog/assets/js/36.56a6bc9a.js"><link rel="prefetch" href="/Agan-blog/assets/js/37.f94705be.js"><link rel="prefetch" href="/Agan-blog/assets/js/38.ede5f11d.js"><link rel="prefetch" href="/Agan-blog/assets/js/39.440a48e8.js"><link rel="prefetch" href="/Agan-blog/assets/js/4.722a81fa.js"><link rel="prefetch" href="/Agan-blog/assets/js/40.59b0244b.js"><link rel="prefetch" href="/Agan-blog/assets/js/41.c5c79df1.js"><link rel="prefetch" href="/Agan-blog/assets/js/42.b32cc047.js"><link rel="prefetch" href="/Agan-blog/assets/js/43.dcf4204c.js"><link rel="prefetch" href="/Agan-blog/assets/js/44.c3669e78.js"><link rel="prefetch" href="/Agan-blog/assets/js/45.b8c83895.js"><link rel="prefetch" href="/Agan-blog/assets/js/46.d5e11c38.js"><link rel="prefetch" href="/Agan-blog/assets/js/47.6e8e6a17.js"><link rel="prefetch" href="/Agan-blog/assets/js/48.5feb8558.js"><link rel="prefetch" href="/Agan-blog/assets/js/49.0f23f936.js"><link rel="prefetch" href="/Agan-blog/assets/js/5.e1e9fbee.js"><link rel="prefetch" href="/Agan-blog/assets/js/50.3817003e.js"><link rel="prefetch" href="/Agan-blog/assets/js/51.947892ad.js"><link rel="prefetch" href="/Agan-blog/assets/js/52.b3d8699f.js"><link rel="prefetch" href="/Agan-blog/assets/js/54.a062f12e.js"><link rel="prefetch" href="/Agan-blog/assets/js/55.49595207.js"><link rel="prefetch" href="/Agan-blog/assets/js/56.7a3249d2.js"><link rel="prefetch" href="/Agan-blog/assets/js/57.6f4387d7.js"><link rel="prefetch" href="/Agan-blog/assets/js/58.0cbc79f7.js"><link rel="prefetch" href="/Agan-blog/assets/js/59.2e2f114c.js"><link rel="prefetch" href="/Agan-blog/assets/js/6.0c2419ec.js"><link rel="prefetch" href="/Agan-blog/assets/js/60.cbae4a83.js"><link rel="prefetch" href="/Agan-blog/assets/js/61.6e70f846.js"><link rel="prefetch" href="/Agan-blog/assets/js/62.f21a405e.js"><link rel="prefetch" href="/Agan-blog/assets/js/63.db589b0d.js"><link rel="prefetch" href="/Agan-blog/assets/js/64.1f95cef9.js"><link rel="prefetch" href="/Agan-blog/assets/js/65.f1408ec1.js"><link rel="prefetch" href="/Agan-blog/assets/js/66.e713aa05.js"><link rel="prefetch" href="/Agan-blog/assets/js/67.3c617fa4.js"><link rel="prefetch" href="/Agan-blog/assets/js/68.d21e34d6.js"><link rel="prefetch" href="/Agan-blog/assets/js/69.31b24de4.js"><link rel="prefetch" href="/Agan-blog/assets/js/7.accc422d.js"><link rel="prefetch" href="/Agan-blog/assets/js/70.cd4f2a03.js"><link rel="prefetch" href="/Agan-blog/assets/js/71.89266fef.js"><link rel="prefetch" href="/Agan-blog/assets/js/72.3307e935.js"><link rel="prefetch" href="/Agan-blog/assets/js/73.5b1aedd1.js"><link rel="prefetch" href="/Agan-blog/assets/js/74.c578d90d.js"><link rel="prefetch" href="/Agan-blog/assets/js/75.65c4c504.js"><link rel="prefetch" href="/Agan-blog/assets/js/76.563a3e33.js"><link rel="prefetch" href="/Agan-blog/assets/js/77.9a401ea8.js"><link rel="prefetch" href="/Agan-blog/assets/js/78.8968edd9.js"><link rel="prefetch" href="/Agan-blog/assets/js/79.e6bc297c.js"><link rel="prefetch" href="/Agan-blog/assets/js/8.977aa7f9.js"><link rel="prefetch" href="/Agan-blog/assets/js/80.803f5cd2.js"><link rel="prefetch" href="/Agan-blog/assets/js/81.0344aa07.js"><link rel="prefetch" href="/Agan-blog/assets/js/82.e830d944.js"><link rel="prefetch" href="/Agan-blog/assets/js/83.9c7bd0a3.js"><link rel="prefetch" href="/Agan-blog/assets/js/84.1d3691d3.js"><link rel="prefetch" href="/Agan-blog/assets/js/85.d0e0eec9.js"><link rel="prefetch" href="/Agan-blog/assets/js/86.7a9b98f1.js"><link rel="prefetch" href="/Agan-blog/assets/js/87.989e4a6a.js"><link rel="prefetch" href="/Agan-blog/assets/js/88.96fb2e84.js"><link rel="prefetch" href="/Agan-blog/assets/js/89.63cf36b0.js"><link rel="prefetch" href="/Agan-blog/assets/js/9.55a60885.js"><link rel="prefetch" href="/Agan-blog/assets/js/90.19849981.js"><link rel="prefetch" href="/Agan-blog/assets/js/91.950b7c76.js"><link rel="prefetch" href="/Agan-blog/assets/js/92.5c148052.js"><link rel="prefetch" href="/Agan-blog/assets/js/93.e926e177.js">
    <link rel="stylesheet" href="/Agan-blog/assets/css/0.styles.1674594c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="ag-container is-page" data-v-1895eed2><div class="ag-header" data-v-312fb2c6 data-v-1895eed2><nav class="ag-nav" data-v-312fb2c6><span data-v-312fb2c6><a href="/Agan-blog/" class="router-link-active" data-v-312fb2c6>首页</a></span><span data-v-312fb2c6><a href="/Agan-blog/pages/d67b9d/" data-v-312fb2c6>设计</a></span><span data-v-312fb2c6><a href="/Agan-blog/pages/8143cc480faf9a11/" data-v-312fb2c6>前端</a></span><span data-v-312fb2c6><a href="/Agan-blog/pages/fe171a/" data-v-312fb2c6>随笔</a></span><span data-v-312fb2c6><a href="/Agan-blog/pages/beb6c0bd8a66cea6" data-v-312fb2c6>收藏夹</a></span><span data-v-312fb2c6><a data-v-312fb2c6>
          其他
          </a></span></nav> <div class="ag-toggle-mode theme-mode" data-v-704e114c data-v-312fb2c6><div class="current-mode" data-v-704e114c>
    自动
  </div> <ul class="select-mode" style="display:none;" data-v-704e114c><li class="light" data-v-704e114c>
      浅色
    </li><li class="dark" data-v-704e114c>
      暗色
    </li><li class="is-active auto" data-v-704e114c>
      自动
    </li></ul></div></div> <div class="ag-body" data-v-1895eed2><div class="ag-slogn" data-v-92e64100 data-v-1895eed2><h1 data-v-92e64100></h1> <h4 data-v-92e64100></h4></div> <div class="ag-page" data-v-a14a39de data-v-1895eed2 data-v-1895eed2><div class="ag-slide-panel ag-side" data-v-302c62e6 data-v-a14a39de><div class="slide-item" data-v-302c62e6><div class="slide-group" data-v-b37a5190 data-v-302c62e6><div class="slide-title" data-v-b37a5190>
      计算机相关
    </div> <ul class="slide-menus" style="display:none;" data-v-b37a5190 data-v-b37a5190><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/772077/" data-v-b37a5190>计算机浏览器相关
              </a></div></li><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/014c11/" data-v-b37a5190>在输入URL之后，浏览器上做了什么
              </a></div></li><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/392a60/" data-v-b37a5190>「前端进阶必备」深入理解现代浏览器
              </a></div></li><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/0ae1a6/" data-v-b37a5190> 重排重绘为什么会影响渲染，如何避免
              </a></div></li><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/450cf0/" data-v-b37a5190>js css 顺序对前端优化影响
              </a></div></li><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/12cf5b/" data-v-b37a5190> 缓存机制
              </a></div></li><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/4cde03/" data-v-b37a5190>HTTP, HTTPS, HTTP2 的区别和联系
              </a></div></li><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/3fb3b0/" data-v-b37a5190>跨域问题
              </a></div></li><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/0d4c51/" data-v-b37a5190>事件循环
              </a></div></li></ul></div></div><div class="slide-item" data-v-302c62e6><div class="slide-group" data-v-b37a5190 data-v-302c62e6><div class="slide-title" data-v-b37a5190>
      HTML
    </div> <ul class="slide-menus" style="display:none;" data-v-b37a5190 data-v-b37a5190><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/17f79a/" data-v-b37a5190> Html
              </a></div></li></ul></div></div><div class="slide-item" data-v-302c62e6><div class="slide-group" data-v-b37a5190 data-v-302c62e6><div class="slide-title" data-v-b37a5190>
      CSS
    </div> <ul class="slide-menus" style="display:none;" data-v-b37a5190 data-v-b37a5190><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/2cf44b/" data-v-b37a5190> CSS
              </a></div></li></ul></div></div><div class="slide-item" data-v-302c62e6><div class="slide-group" data-v-b37a5190 data-v-302c62e6><div class="slide-title" data-v-b37a5190>
      JS
    </div> <ul class="slide-menus" style="display:none;" data-v-b37a5190 data-v-b37a5190><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/85e0ff/" aria-current="page" class="router-link-exact-active router-link-active" data-v-b37a5190> Js
              </a></div></li></ul></div></div><div class="slide-item" data-v-302c62e6><div class="slide-group" data-v-b37a5190 data-v-302c62e6><div class="slide-title" data-v-b37a5190>
      框架
    </div> <ul class="slide-menus" style="display:none;" data-v-b37a5190 data-v-b37a5190><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/07183b/" data-v-b37a5190> Webpack
              </a></div></li><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/4a6389/" data-v-b37a5190> Vue
              </a></div></li><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/bafb86/" data-v-b37a5190> React
              </a></div></li></ul></div></div><div class="slide-item" data-v-302c62e6><div class="slide-group" data-v-b37a5190 data-v-302c62e6><div class="slide-title" data-v-b37a5190>
      Node
    </div> <ul class="slide-menus" style="display:none;" data-v-b37a5190 data-v-b37a5190><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/c2c1d1/" data-v-b37a5190> Node
              </a></div></li></ul></div></div><div class="slide-item" data-v-302c62e6><div class="slide-link" data-v-b37a5190 data-v-302c62e6><a href="/Agan-blog/pages/c15f88/" data-v-b37a5190>性能优化
              </a></div></div><div class="slide-item" data-v-302c62e6><div class="slide-group" data-v-b37a5190 data-v-302c62e6><div class="slide-title" data-v-b37a5190>
      算法
    </div> <ul class="slide-menus" style="display:none;" data-v-b37a5190 data-v-b37a5190><li class="slide-menu" data-v-b37a5190><div class="slide-link" data-v-b37a5190 data-v-b37a5190><a href="/Agan-blog/pages/6f88c1/" data-v-b37a5190> 算法
              </a></div></li></ul></div></div><div class="slide-item" data-v-302c62e6><div class="slide-link" data-v-b37a5190 data-v-302c62e6><a href="/Agan-blog/pages/7d2fc9/" data-v-b37a5190>一些概念
              </a></div></div></div> <div class="ag-main" data-v-a14a39de><div class="ag-content" data-v-a14a39de><div class="content__default" data-v-a14a39de data-v-a14a39de><h1 id="js"><a href="#js" class="header-anchor">#</a> JS</h1> <p>[TOC]</p> <h2 id="_1-基础类型和类型检测"><a href="#_1-基础类型和类型检测" class="header-anchor">#</a> 1 基础类型和类型检测</h2> <ul><li>简单类型：Undefined, Null, boolean, number, string，Symbol。 <em>存储结构-栈</em></li> <li>复杂类型：Object, Array, Date, Function, RegExp，Set, Map <em>存储结构-堆</em></li> <li>基本包装类型：Boolean, Number, String ）<em>存储结构-堆</em></li></ul> <p>类型检测</p> <ul><li>typeof: 区分不了引用类型（typeof null === Object）</li> <li>instanceof: 区分不来普通类型</li> <li>constructor: 容易篡改</li> <li>Object.prototype.toString.call()： 完美(ES6 的也能区分)</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token punctuation">[</span>Object String<span class="token punctuation">]</span>
<span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>Null<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token punctuation">[</span>Object Null<span class="token punctuation">]</span>

</code></pre></div><h2 id="_2-类型转换"><a href="#_2-类型转换" class="header-anchor">#</a> 2 类型转换</h2> <h3 id="_2-1-undefined-null"><a href="#_2-1-undefined-null" class="header-anchor">#</a> 2.1 undefined, null</h3> <ul><li>undefined: undefined 的字面意思就是未定义的值，这个值的语义是，希望表示一个变量最原始的状态，而非人为操作的结果</li> <li>null: null 的字面意思是空值，这个值的语义是，希望表示 一个对象被人为的重置为空对象，而非一个变量最原始的状态 规定 undefined == null 表示其行为相似性</li> <li>void 0 === undefined</li></ul> <h3 id="_2-2-与"><a href="#_2-2-与" class="header-anchor">#</a> 2.2 == 与 ===</h3> <ul><li>=== 严格相等
<ul><li>类型相等</li> <li>普通类型值相等， 引用类型的地址相等</li></ul></li> <li>== 相同 （带类型转换）
<ul><li>undefined == null</li> <li>使用 toPrimitive 转换成原始值后比较</li></ul></li></ul> <h3 id="_2-3-原始值转换函数-toprimitive-input-preferredtype"><a href="#_2-3-原始值转换函数-toprimitive-input-preferredtype" class="header-anchor">#</a> 2.3 原始值转换函数 toPrimitive(input，PreferredType?)</h3> <p>toPrimitive(input，PreferredType?) 函数将 input 转换成原始值，PreferredType 是转化偏向</p> <ul><li><p>如果 input 是原始值，则返回 input</p></li> <li><p>如果 input 是对象（广义）</p> <ul><li><p>PreferredType 是 Number:</p> <ol><li>调用 obj.valueOf(), 如果是原始值则返回，否则进入 2</li> <li>调用 obj.toString(), 如果是原始值则返回，否则抛出 TypeError 异常</li></ol></li> <li><p>PreferredType 是 String:</p> <ol><li>调用 obj.toString(), 如果是原始值则返回，否则进入 2</li> <li>调用 obj.valueOf(), 如果是原始值则返回，否则抛出 TypeError 异常</li></ol></li> <li><p>PreferredType 未填: Date 类型的对象 PreferredType 默认 String，其它类型的值会被设置为 Number</p></li></ul></li> <li><p>(+, -, ==)等运算符，会使得 PreferredType 为 Number，但如有有一元为 String，则 PreferredType 为 String</p></li> <li><p>null 和 undefined 是特殊的原始类型，他们不会转换成其他任何值，那么也不会调用该方法。且规范定义 undefined == null</p></li></ul> <p>注意：</p> <ul><li>[]转换成字符串为“”</li> <li>[]转换成 boolean 为 true；</li> <li>[]转换成数字为 0；</li></ul> <h3 id="_2-4-valueof-和-tostring"><a href="#_2-4-valueof-和-tostring" class="header-anchor">#</a> 2.4 valueOf 和 toString</h3> <ol><li>toString: 将值转换为字符串形式并返回，不同类型的 toString 方法各有不同</li></ol> <table><thead><tr><th style="text-align:center;">类型</th> <th style="text-align:center;">返回值</th></tr></thead> <tbody><tr><td style="text-align:center;">Number</td> <td style="text-align:center;">返回数字的字符串形式。注意：10.toString()报错，10..toString()会把第一个.当作小数点</td></tr> <tr><td style="text-align:center;">String</td> <td style="text-align:center;">直接返回原字符串的值</td></tr> <tr><td style="text-align:center;">Boolean</td> <td style="text-align:center;">返回文本表示'true'或'false'</td></tr> <tr><td style="text-align:center;">Object</td> <td style="text-align:center;">返回[object 类型名]</td></tr> <tr><td style="text-align:center;">Array</td> <td style="text-align:center;">将数组元素转换为字符串，用逗号拼接并返回</td></tr> <tr><td style="text-align:center;">Function</td> <td style="text-align:center;">直接返回函数的文本声明</td></tr> <tr><td style="text-align:center;">Date</td> <td style="text-align:center;">返回日期的文本表示</td></tr> <tr><td style="text-align:center;">RegExp</td> <td style="text-align:center;">返回正则的字符串表示'/pattern/flag'</td></tr></tbody></table> <ol start="2"><li>valueOf: 返回类型的值</li></ol> <table><thead><tr><th style="text-align:center;">类型</th> <th style="text-align:center;">返回值</th></tr></thead> <tbody><tr><td style="text-align:center;">Number</td> <td style="text-align:center;">返回原始类型的数字值</td></tr> <tr><td style="text-align:center;">String</td> <td style="text-align:center;">返回原始类型的字符串值</td></tr> <tr><td style="text-align:center;">Boolean</td> <td style="text-align:center;">返回原始类型的 Boolean</td></tr> <tr><td style="text-align:center;">Object</td> <td style="text-align:center;">返回对象本身</td></tr> <tr><td style="text-align:center;">Array</td> <td style="text-align:center;">方法继承于 Object.prototype,返回原数组</td></tr> <tr><td style="text-align:center;">Function</td> <td style="text-align:center;">方法继承于 Object.prototype,返回函数本身</td></tr> <tr><td style="text-align:center;">Date</td> <td style="text-align:center;">方法等同于 getTime，返回时间戳</td></tr> <tr><td style="text-align:center;">RegExp</td> <td style="text-align:center;">方法继承于 Object.prototype,返回值本身</td></tr></tbody></table> <h2 id="_3-原型和原型链"><a href="#_3-原型和原型链" class="header-anchor">#</a> 3 原型和原型链</h2> <h3 id="_3-1-原型"><a href="#_3-1-原型" class="header-anchor">#</a> 3.1 原型</h3> <p>每一个 JavaScript 对象(null 除外)在创建的时候就会关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型&quot;继承&quot;属性和方法。</p> <ul><li><strong>proto</strong> 是对象实例才有的属性，指向对象的原型。</li> <li>prototype 是构造函数才有的属性，该属性指向了一个对象，这个对象正是调用该构造函数而创建的实例的原型</li> <li>实例的<strong>proto</strong>属性 和 构造函数的 prototype 都指向该对象原型</li> <li>Function 的 prototype 和<strong>proto</strong>属性都指向 f () 匿名函数</li> <li>Object 作为构造函数时，他的 prototype 指向 Object.prototype 对象原型，作为实例时，他的<strong>proto</strong>指向匿名函数。我们可以认为 Function 实例和 Object 实例都是继承于该匿名函数。</li> <li>匿名函数作为“顶级构造函数”，他不需要 prototype 属性，即 prototype=undefined，当作为对象时，他的对象原型是 Object.prototype。</li> <li>Object.prototype 作为“顶级构造对象”，他的<strong>proto</strong>等于 null，表示继承于一个空的对象。没有 prototype 属性。</li></ul> <p>送大家一张值得刻脑子里的图：</p> <p><img src="https://gitee.com/zukunft/MDImage/raw/master/img/20200901235529.png" alt="ff"></p> <h3 id="_3-2-原型链"><a href="#_3-2-原型链" class="header-anchor">#</a> 3.2 原型链</h3> <p>用 proto 链接的这条就是我们的原型链。原型链用于查找对象上的属性，当属性未从当前的对象上获取到的时候会从该原型链上查找，直到查到相应的属性。</p> <p>原型链的顶层指向 window，严格模式下不会指向 window 而是 undefined</p> <h2 id="_4-闭包"><a href="#_4-闭包" class="header-anchor">#</a> 4 闭包</h2> <p>闭包是函数和声明该函数的词法环境的组合，这个环境包含了这个闭包创建时所能访问的所有局部变量</p> <p>可能产生闭包的二种情况：</p> <ul><li>函数作为返回值，</li> <li>函数作为参数传递</li></ul> <p>优点:</p> <ul><li>可以读取函数内部的变量</li> <li>另一个就是让这些变量的值始终保持在内存中，不会在函数调用后被自动清除，同时这也算是个缺点。（在函数中 return 一个函数出来）</li> <li>可用于模拟私有变量和方法</li></ul> <p>缺点:</p> <ul><li>消耗内存，影响网页性能</li> <li>可能会引起内存泄漏（不再用到的内存，但是没有及时释放，就叫做内存泄漏）</li></ul> <h2 id="_5-this"><a href="#_5-this" class="header-anchor">#</a> 5 this</h2> <p>第一准则是：this 永远指向函数运行时所在的对象，而不是函数被创建时所在的对象。</p> <ul><li>this 指的是当前的执行环境</li> <li>普通的函数调用，函数被谁调用，this 就是谁</li> <li>构造函数的话，如果不用 new 操作符而直接调用，那即 this 指向 window。用 new 操作符生成对象实例后，this 就指向了新生成的对象。</li> <li>匿名函数或不处于任何对象中的函数指向 window 。</li> <li>bind call apply with 函数可以绑定 this 的指向
<ul><li>call: call(this, arg1, arg2, ...)。会执行该函数</li> <li>apply: apply(this, firstArg | argArray[]) 多个参数可使用参数数组，会执行该函数</li> <li>bind: bind(this, firstArg | argArray[]) 返回一个函数，函数内的 this 指向传入的 this</li> <li>with: with (expression) { statement } // with'语句將某个对象添加到作用域链的顶部(window 之下，没有切断作用域链，在 expression 中找不到定义的，仍会往 window 上寻找)，在严格模式该标签禁止使用</li></ul></li></ul> <h2 id="_6-new-的原理"><a href="#_6-new-的原理" class="header-anchor">#</a> 6 new 的原理</h2> <ol><li>创建一个空对象，构造函数中的 this 指向这个空对象</li> <li>这个新对象的<strong>proto</strong>设置为即构造函数的 prototype</li> <li>执行构造函数方法，属性和方法被添加到 this 引用的对象中</li> <li>如果构造函数中没有返回其它对象，那么返回 this，即创建的这个的新对象，否则，返回构造函数中返回的对象。</li></ol> <h3 id="_6-1-实现一个-new-函数"><a href="#_6-1-实现一个-new-函数" class="header-anchor">#</a> 6.1 实现一个 new 函数</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">_new</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">factory<span class="token punctuation">,</span> <span class="token operator">...</span>rest</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> o <span class="token operator">=</span> <span class="token punctuation">{</span>
    __proto__<span class="token operator">:</span> factory<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> rest<span class="token punctuation">)</span>
  <span class="token keyword">return</span> <span class="token keyword">typeof</span> res <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">?</span> res <span class="token operator">:</span> o
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_7-class-和继承"><a href="#_7-class-和继承" class="header-anchor">#</a> 7 class 和继承</h2> <h3 id="_7-1-class"><a href="#_7-1-class" class="header-anchor">#</a> 7.1 class</h3> <p>ES6 之前实例化对象是通过构造函数实现的，ES6 后可以通过关键字 class 创建类（可以认为是一种语法糖）</p> <ul><li>class 中的 constructor 就是在实例化对象调用的构造函数，该构造函数可不写。</li> <li>实例对象必须使用 new 关键字生成</li> <li>class 不可以当做函数执行</li> <li>class 不存在变量提升</li> <li>class 中定义的属性和方法都挂在原型上，所有的实例对象都有这些属性和方法。构造函数中定义的是实例的属性和方法。</li> <li>class 中可以通过 static 定义静态方法，静态变量需在类外声明（calss.staticName==staticValue）。静态属性和方法只可以通过 class 来调用，实例不可调用</li></ul> <h3 id="_7-2-继承"><a href="#_7-2-继承" class="header-anchor">#</a> 7.2 继承</h3> <p>继承属性，方法，静态方法</p> <ul><li>ES6 继承: 通过 extends 关键字</li> <li>ES5 继承: 通过修改原型链实现继承</li></ul> <p>本质：</p> <ul><li>ES5 的继承，实质是先创造子类的实例对象 this，然后再将父类的方法添加到 this 上面（Parent.apply(this)）。</li> <li>ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 this 上面（所以必须先调用 super 方法），然后再用子类的构造函数修改 this。</li></ul> <h3 id="_7-3-es5-实现继承的几种方式"><a href="#_7-3-es5-实现继承的几种方式" class="header-anchor">#</a> 7.3 ES5-实现继承的几种方式</h3> <ol><li>原型链继承：替换子类型的原型</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">superClass</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">subClass</span><span class="token punctuation">(</span><span class="token parameter">sex</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> sex
<span class="token punctuation">}</span>

<span class="token comment">// 继承了superClass</span>
subClass<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">superClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>缺点：</p> <ul><li>包含引用类型的原型属性会被所有实例共享</li> <li>在创建子类型的实例时，不能向超类型的构造函数中传递参数</li></ul> <ol start="2"><li>经典继承（借用构造函数）：为了避免实例共享原型属性而带来的技术</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">subClass</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> sex</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 继承了superClass的属性</span>
  <span class="token function">superClass</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> sex
<span class="token punctuation">}</span>
</code></pre></div><p>缺点:</p> <ul><li>无法做到函数复用</li> <li>不能继承超类型在原型上定义的方法</li></ul> <ol start="3"><li>组合继承：融合了原型链继承和经典继承，避免了他们的缺陷</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">subClass</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> sex</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 继承了superClass的属性</span>
  <span class="token function">superClass</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span> <span class="token comment">// 第一次调用</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> sex
<span class="token punctuation">}</span>
<span class="token comment">// 继承方法</span>
subClass<span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">superClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 第二次调用</span>
subClass<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> subClass
</code></pre></div><p>缺点:</p> <ul><li>需要调用两次超类型的构造函数</li></ul> <ol start="4"><li>原型继承：基于已有的对象创建新的对象</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 以一个对象作为实例的原型对象</span>
<span class="token keyword">function</span> <span class="token function">object</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">function</span> <span class="token constant">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token class-name">F</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> o
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">F</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// 在ES5 规范化了该继承</span>
Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>缺点：</p> <ul><li>包含引用类型的原型属性会被所有实例共享</li></ul> <ol start="5"><li>寄生式继承：思路和工厂模式类似，即创建一个仅用于继承过程的函数</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">createAnother</span><span class="token punctuation">(</span><span class="token parameter">o</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建新对象</span>
  <span class="token keyword">var</span> clone <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span>
  <span class="token comment">// 增强这个对象</span>
  o<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">return</span> o
<span class="token punctuation">}</span>
</code></pre></div><p>缺点：</p> <ul><li>无法做到函数复用</li></ul> <ol start="6"><li>寄生式组合继承：通过构造函数来继承属性，通过原型链的混成形式来继承方法</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">inheritsPrototype</span><span class="token punctuation">(</span><span class="token parameter">subClass<span class="token punctuation">,</span> superClass</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>superClass<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span>
  prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> subClass
  subClass<span class="token punctuation">.</span>prototype <span class="token operator">=</span> prototype
<span class="token punctuation">}</span>
</code></pre></div><p>集寄生式继承和组合继承的优点于一身，是实现基于类型继承的最有效方式</p> <blockquote><p>答案来自《JavaScript 高级程序设计》第六章</p></blockquote> <h3 id="_7-4-实现一个继承-inherits-函数"><a href="#_7-4-实现一个继承-inherits-函数" class="header-anchor">#</a> 7.4 实现一个继承 inherits 函数</h3> <p>使用上面所述的寄生组合式继承</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">inherits</span><span class="token punctuation">(</span><span class="token parameter">subClass<span class="token punctuation">,</span> superClass</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// ... 省略参数校验</span>
  subClass<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>superClass<span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    constructor<span class="token operator">:</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> subClass<span class="token punctuation">,</span> writable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> configurable<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">//使用</span>
<span class="token keyword">function</span> <span class="token function">superClass</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name
<span class="token punctuation">}</span>

superClass<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">say</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">hello my name is </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">subClass</span><span class="token punctuation">(</span><span class="token parameter">name<span class="token punctuation">,</span> sex</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">superClass</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> name<span class="token punctuation">)</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>sex <span class="token operator">=</span> sex
<span class="token punctuation">}</span>

<span class="token function">_inherits</span><span class="token punctuation">(</span>subClass<span class="token punctuation">,</span> superClass<span class="token punctuation">)</span>
</code></pre></div><h2 id="_8-es6-7"><a href="#_8-es6-7" class="header-anchor">#</a> 8 ES6/7</h2> <h3 id="_8-1-let-const-和-var-的区别"><a href="#_8-1-let-const-和-var-的区别" class="header-anchor">#</a> 8.1 let, const 和 var 的区别</h3> <ul><li>let 和 var 都用于声明变量，而 const 必须初始化，且用于声明常量，这个常量指的是普通类型的值不变和复杂类型的内存地址不变。</li> <li>var 存在变量提升，而 let，const 存在“<strong>暂时性死区</strong>”，即在变量声明之前就访问变量的话，会直接提示 ReferenceError，而不像 var 那样使用默认值 undefined</li> <li>let,const 只有块级作用域，而 var 只有全局作用域和函数作用域概念</li></ul> <h3 id="_8-2-箭头函数"><a href="#_8-2-箭头函数" class="header-anchor">#</a> 8.2 箭头函数</h3> <ul><li>更简化的代码语法</li> <li>不绑定 this， 这也意味着使用 call 和 apply 是无法传递 this，第一个参数就是需要传递的参数</li> <li>arguments，即没有函数的参数 arguments，但可以使用剩余参数...args 替代</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">arg1<span class="token punctuation">,</span> arg2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> args<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
  <span class="token keyword">return</span> <span class="token function">f</span><span class="token punctuation">(</span>arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 2</span>
</code></pre></div><ul><li>不能使用 new 关键字，因为箭头函数不是一个构造函数</li> <li>没有 prototype 属性</li> <li>yield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作生成器。</li> <li>如果需要放回对象字面量，可以</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 或</span>
<span class="token keyword">var</span> <span class="token function-variable function">func</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_8-3-promise"><a href="#_8-3-promise" class="header-anchor">#</a> 8.3 Promise</h3> <p>所谓 Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。</p> <p>Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。清晰的代码结构。避免出现回调地狱</p> <p>Promise 具有三种状态，分别是初始化的 pending 状态，resolve 后的 fulfilled 状态，rejecte 后的 rejected 状态。</p> <p>常用方法:</p> <p>then 和 catch 实际上是注册异步操作成功或失败的回调函数</p> <ul><li>Promise.prototype.then() ： 可以有两个参数，第一个是 resolve 的回调，第二个是 reject 的回调</li> <li>Promise.prototype.catch()： 相当于.then(null, rejectFun)</li> <li>Promise.prototype.finally() 【ES8】</li> <li>Promise.all(): 只有所有都个变成 fulfilled 状态，包装实例才会变成 fulfilled 状态；如果有一个实例变成 rejected 状态，包装实例就会变成 rejected 状态。</li> <li>Promise.allSettled(): 等到所有这些参数实例都返回结果，不管是 fulfilled 还是 rejected，包装实例才会结束。该方法由【ES2020】引入。</li> <li>Promise.any(): 只要实例有一个变成 fulfilled 状态，包装实例就会变成 fulfilled 状态；如果所有参数实例都变成 rejected 状态，包装实例就会变成 rejected 状态。该方法目前是一个第三阶段的提案 。</li> <li>Promise.race(): 异步操作竞赛，只返回最快的一个</li> <li>Promise.resolve()</li> <li>Promise.reject()</li> <li>Promise.try(): 同步操作也可以像异步一样执行</li></ul> <h3 id="_8-4-generator"><a href="#_8-4-generator" class="header-anchor">#</a> 8.4 generator</h3> <p>generator 是 ES6 提供的一种异步编程解决方案，在语法上，可以把它理解为一个状态机，内部封装了多种状态。执行 generator，会生成返回一个遍历器对象。返回的遍历器对象，可以依次遍历 generator 函数的每一个状态。同时 ES6 规定这个遍历器是 Generator 函数的实例，也继承了 Genarator 函数的 prototype 对象上的方法。</p> <p>Generator(生成器)是一类特殊的函数</p> <p>一是，function 关键字与函数名之间有一个星号； 二是，函数体内部使用 yield 表达式，定义不同的内部状态（yield 在英语里的意思就是“产出”）。</p> <ul><li><p><strong>Iterator(迭代器)</strong>：当我们实例化一个生成器函数之后，这个实例就是一个迭代器。可以通过 next()方法去启动生成器以及控制生成器的是否往下执行。</p></li> <li><p><strong>yield/next</strong>：这是控制代码执行顺序的一对好基友。通过 yield 语句可以在生成器函数内部暂停代码的执行使其挂起，此时生成器函数仍然是运行并且是活跃的，其内部资源都会保留下来，只不过是处在暂停状态。在迭代器上调用<code>next()</code>方法可以使代码从暂停的位置开始继续往下执行。</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">Mxx</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">yield</span> <span class="token string">'hello'</span>
  <span class="token keyword">yield</span> <span class="token string">'world'</span>
  <span class="token keyword">return</span> <span class="token string">'ending'</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> mxx <span class="token operator">=</span> <span class="token function">Mxx</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

mxx<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// { value: 'hello', done: false }</span>

mxx<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// { value: 'world', done: false }</span>

mxx<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// { value: 'ending', done: true }</span>

mxx<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">// { value: undefined, done: true }</span>
</code></pre></div><h3 id="_8-5-async-await"><a href="#_8-5-async-await" class="header-anchor">#</a> 8.5 async await</h3> <p><code>async</code> 函数是 <code>Generator</code> 函数的语法糖。使用 <code>async</code> 关键字代替 <code>Generator</code> 函数的星号 <code>*</code>，<code>await</code> 关键字代替 <code>yield</code>。相较于 Generator 函数，async 函数改进了以下四点：</p> <ul><li><strong>内置执行器</strong> <code>Generator</code> 函数的执行必须靠执行器，所以才有了 <code>co</code> 模块，而 <code>async</code> 函数自带执行器。</li> <li><strong>更好的语义</strong> <code>async</code> 和 <code>await</code>，比起 <code>*</code> 和 <code>yield</code>，语义更清楚。<code>async</code> 表示函数里有异步操作，<code>await</code> 表示紧跟在后面的表达式需要等待结果。</li> <li><strong>更广的适用性</strong> <code>co</code> 模块约定，<code>yield</code> 命令后面只能是 Thunk 函数或 Promise 对象，而<code>async</code> 函数的<code>await</code> 命令后面，可以是 Promise 对象和原始类型的值。</li> <li><strong>返回值是 Promise</strong> <code>async</code> 函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用 <code>then</code> 方法指定下一步的操作。</li></ul> <p><strong>async 特性：</strong></p> <ul><li>async 表示函数里有异步操作， await 表示紧跟在后面的表达式需要<strong>等待结果</strong></li> <li>async 函数的返回值是 Promise 对象，可以用 then 方法添加回调函数，此时 then 的参数是函数内部 return 语句返回的值。</li> <li>当函数执行时，一旦遇到 await 就会先暂停，等到异步操作完成，再接着执行函数体内后面的语句。</li> <li>async 函数返回的 promise 对象，必须等到内部所有 await 命令后面的 promise 对象执行完，才会发生状态变化，执行 then 方法指定的回调函数。</li></ul> <p><strong>await 特性：</strong></p> <ul><li>await 命令后面是一个 promise 对象，返回该对象的结果，如果不是 promise 对象或者 thenable 对象，就直接返回对应的值。</li> <li>await 命令后面的 Promise 对象如果变成 reject 状态，则会被 async 函数的 catch 捕获到。</li> <li>任何一个 await 后的 promise 对象变为 reject 状态，那么整个 async 函数都会中断执行。</li> <li>可以用 Promise.all，让并行的 异步请求同时执行。</li></ul> <h3 id="_8-6-weak-set-weak-map"><a href="#_8-6-weak-set-weak-map" class="header-anchor">#</a> 8.6 (Weak)Set / (Weak)Map</h3> <p><code>Set</code> 和 <code>Map</code> 都是 ES6 新增数据结构。</p> <h4 id="set"><a href="#set" class="header-anchor">#</a> Set</h4> <p><code>Set</code> 是一个集合，它类似于数组，但是成员的值都是唯一的，没有重复的值。它允许你存储任何类型的唯一值，无论是原始值或者是对象引用。</p> <p><code>Set</code> 是一个构造函数，它有一个可选的参数一个<a href="https://juejin.im/post/6844903788898172935" target="_blank" rel="noopener noreferrer">可迭代对象<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>。如果传递了这个参数它的所有元素将不重复地被添加到新的 <code>Set</code>中。如果不指定此参数或其值为<code>null</code>，则新的<code>Set</code>为空。它返回一个新的<code>Set</code>实例。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
  <span class="token number">NaN</span><span class="token punctuation">,</span>
  <span class="token keyword">undefined</span><span class="token punctuation">,</span>
  <span class="token keyword">null</span><span class="token punctuation">,</span>
  <span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">,</span>
  <span class="token number">Infinity</span><span class="token punctuation">,</span>
  <span class="token operator">-</span><span class="token number">Infinity</span><span class="token punctuation">,</span>
  <span class="token number">NaN</span><span class="token punctuation">,</span>
  <span class="token keyword">undefined</span><span class="token punctuation">,</span>
  <span class="token keyword">null</span><span class="token punctuation">,</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span>
<span class="token comment">/*
Set(6) {NaN, undefined, null, 0, Infinity, …}
    size: 6
    __proto__: Set
    [[Entries]]: Array(6)
        0: NaN
        1: undefined
        2: null
        3: 0
        4: Infinity
        5: -Infinity
        length: 6
*/</span>
<span class="token comment">// 可以发现在 Set 中 NaN 之间被视为相同的值</span>
</code></pre></div><p><code>Set</code>常用于去除重复元素。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 去除数组的重复成员</span>
<span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token comment">// 去除重复字符</span>
<span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token string">'abcabc'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="weakset"><a href="#weakset" class="header-anchor">#</a> WeakSet</h4> <p><code>WeakSet</code>和<code>Set</code>类似，但是有两点不同：</p> <ol><li><code>WeakSet</code>对象中只能存放对象引用, 不能存放值, 而<code>Set</code>对象都可以.</li> <li><code>WeakSet</code>对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, <code>WeakSet</code>对象是无法被枚举的, 没有办法拿到它包含的所有元素.</li></ol> <h4 id="map"><a href="#map" class="header-anchor">#</a> Map</h4> <p><code>Map</code>对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。它和 JS 对象不同，JS 对象只能用字符串和<a href="https://juejin.im/post/6844903791624454157" target="_blank" rel="noopener noreferrer">Symbol<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>作为键，而<code>Map</code>可以使用任何值。</p> <p>除了键类型上的不同，它和<code>Object</code>还有以下不同：</p> <ol><li><code>Map</code>中的键值是有序的，而添加到对象中的键则不是。</li> <li><code>Map</code>可以通过<code>size</code>获取键值对个数，而<code>Object</code>的键值对个数只能手动计算。</li> <li><code>Map</code>可直接进行迭代，而 Object 的迭代需要先获取它的键数组，然后再进行迭代。</li> <li><code>Object</code>都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。虽然<code>ES5</code>开始可以用<code>map = Object.create(null)</code> 来创建一个没有原型的对象，但是这种用法不太常见。</li> <li><code>Map</code>在涉及频繁增删键值对的场景下会有些性能优势。</li></ol> <h4 id="weakmap"><a href="#weakmap" class="header-anchor">#</a> WeakMap</h4> <p><code>WeakSet</code>对象允许你将弱保持对象存储在一个集合中。</p> <p>它和<code>Map</code>类似，但有两点不同：</p> <ol><li><code>WeakSet</code>对象中只能存放对象引用, 不能存放值, 而<code>Set</code>对象都可以。</li> <li><code>WeakSet</code>对象中存储的对象值都是被弱引用的, 如果没有其他的变量或属性引用这个对象值, 则这个对象值会被当成垃圾回收掉. 正因为这样, <code>WeakSet</code>对象是无法被枚举的, 没有办法拿到它包含的所有元素.</li></ol> <h3 id="decorator"><a href="#decorator" class="header-anchor">#</a> Decorator</h3> <h2 id="_9-number"><a href="#_9-number" class="header-anchor">#</a> 9 Number</h2> <h3 id="_9-1-最大安全数"><a href="#_9-1-最大安全数" class="header-anchor">#</a> 9.1 最大安全数</h3> <p>js 使用 8 位浮动数存储数字，范围是-2^63 ~ 2^63 - 1。但是在超过一定的值后执行加减法就不正确了，这个值叫做最大安全值。</p> <p>最大安全值为 2^53-1 最大安全值为-2^53+1</p> <p>js 中 Number 的存储结构是：</p> <ul><li>1 位符号位</li> <li>11 位指数位</li> <li>52 位尾数位</li></ul> <p>浮点数在保存数字的时候做了规格化处理，对于二进制来说， 小数点前保留一位， 规格化后始终是 1.***, 节省了 1 bit，这个 1 并不需要保存。所以是 52+1=53。</p> <p>可以使用第三方库如 bignum, bigInt 等处理</p> <h3 id="_9-2-浮点数计算精确度问题"><a href="#_9-2-浮点数计算精确度问题" class="header-anchor">#</a> 9.2 浮点数计算精确度问题</h3> <p>因为浮点数在计算机内是以二进制存储和计算的，所以在浮点数上计算会存在精度问题如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token number">0.1</span> <span class="token operator">+</span> <span class="token number">0.2</span> <span class="token operator">=</span> <span class="token number">0.30000000000000004</span>
<span class="token number">1.0</span> <span class="token operator">-</span> <span class="token number">0.9</span> <span class="token operator">=</span> <span class="token number">0.09999999999999998</span>
</code></pre></div><ul><li>使用 toFixed 进行“四舍五入”</li> <li>将数扩大至整数，在进行计算</li> <li>使用例如 number-precision 等第三库进行计算</li></ul> <p><strong>值得注意的是</strong></p> <p>toFixed 并不是正整的四舍五入。而是使用更公平的银行家舍入法。具体规则是：</p> <blockquote><p>四舍六入五考虑，五后非零就进一<br>
五后为零看奇偶，五前为偶应舍去，五前为奇要进一</p></blockquote> <h2 id="_10-array"><a href="#_10-array" class="header-anchor">#</a> 10 Array</h2> <h3 id="_10-1-数组的常用方法"><a href="#_10-1-数组的常用方法" class="header-anchor">#</a> 10.1 数组的常用方法</h3> <p><em><strong>改变原数组</strong></em>:</p> <ul><li>pop(), push(),shift(),unshift()</li> <li>reverse(),sort()</li> <li>splice(index, howMany, newAddItem1, newAddItem2, ...) .. 删除项</li> <li>forEach</li></ul> <p>其他：</p> <ul><li>map, filter, every, some</li> <li>find, findIndex</li> <li>reduce</li> <li>join</li></ul> <h3 id="_10-2-map-和-foreach-的区别"><a href="#_10-2-map-和-foreach-的区别" class="header-anchor">#</a> 10.2 map 和 forEach 的区别</h3> <ul><li>都支持三个参数，参数分别为 item（当前每一项），index（索引值），arr（原数组）</li> <li>forEach 允许 callback 更改原始数组的元素，无返回值。map 则返回新的数组，表现上可认为是浅拷贝后进行操作。 forEach，filter，every，some 会跳过空位，map 会跳过空位，但是会保留这个值。</li></ul> <h3 id="_10-3-typed-arrays"><a href="#_10-3-typed-arrays" class="header-anchor">#</a> 10.3 Typed Arrays</h3> <p>JavaScript 类型数组（Typed Arrays）将实现拆分为<strong>缓冲</strong>和<strong>视图</strong>两部分。它是一种处理二进制数据的特殊数组，像 C 语言那样直接操纵字节，不过得先用 ArrayBuffer 对象创建数组缓冲区（Array Buffer），再映射到指定格式的视图（view）之后，才能读写其中的数据。总共有两类视图，分别是特定类型的 TypedArray 和通用类型的 DataView。在 ES6 引入类型化数组之后，大大提升了 JavaScript 数学运算的性能。</p> <blockquote><p><strong>ArrayBuffer 对象</strong>：代表内存之中的一段二进制数据，可以通过“视图”进行操作。“视图”部署了数组接口，这意味着，可以用数组的方法操作内存。</p> <p><strong>TypedArray 对象</strong>：用来生成内存的视图，通过 9 个构造函数，可以生成 9 种数据格式的视图</p> <p><strong>DataView 对象</strong>：用来生成内存的视图，可以自定义格式和字节序</p> <p><strong>简单说，ArrayBuffer 对象代表原始的二进制数据，TypedArray 对象代表确定类型的二进制数据，DataView 对象代表不确定类型的二进制数据。它们支持的数据类型一共有 9 种（DataView 对象支持除 Unit8c 以外的其他 8 种）</strong></p></blockquote> <h4 id="arraybuffer-缓冲区"><a href="#arraybuffer-缓冲区" class="header-anchor">#</a> ArrayBuffer(缓冲区)</h4> <p>虽然 ArrayBuffer 对象可以开辟一片固定大小的内存区域（即数组缓冲区），但它不能直接读写所存储的数据，需要借助视图(TypeArray 和 DataView)来读写。</p> <h4 id="typedarray"><a href="#typedarray" class="header-anchor">#</a> TypedArray</h4> <p>ArrayBuffer 对象作为内存区域，可以存放多种类型的数据。同一段内存，不同数据有不同的解读方式，这就叫做“视图”（view）。ArrayBuffer 有两种视图，一种是 TypedArray 视图，另一种是 DataView 视图，两者的区别主要是字节序，前者的数组成员都是同一个数据类型，后者的数组成员可以是不同的数据类型。目前，TypedArray 对象一共提供 9 种类型的视图，每一种视图都是一种构造函数。</p> <h4 id="dataview"><a href="#dataview" class="header-anchor">#</a> DataView</h4> <p>如果一段数据包括多种类型（比如服务器传来的 HTTP 数据），这时除了建立 ArrayBuffer 对象的复合视图以外，还可以通过<code>DataView</code>视图进行操作。</p> <p><code>DataView</code>视图提供更多操作选项，而且支持设定字节序。本来，在设计目的上，<code>ArrayBuffer</code>对象的各种 TypedArray 视图，是用来向网卡、声卡之类的本机设备传送数据，所以使用本机的字节序就可以了；而<code>DataView</code>视图的设计目的，是用来处理网络设备传来的数据，所以大端字节序或小端字节序是可以自行设定的。</p> <h2 id="_11-for-循环-foreach-for-in-for-of-的区别"><a href="#_11-for-循环-foreach-for-in-for-of-的区别" class="header-anchor">#</a> 11 for 循环,forEach, for in,for of 的区别</h2> <ol><li><p>普通 for 循环</p></li> <li><p>forEach：普通 for 循环简写，但不能中断循环</p></li> <li><p>for in</p> <ul><li>索引为字符串</li> <li>无顺序（通常用于对象或 json 中）</li> <li>可扩展属性也会遍历</li> <li>为循环”enumerable“对象而设计</li></ul></li> <li><p>for of</p> <ul><li>不支持对象的遍历</li> <li>具有 obj[Symbol.iterator] 的数据使用，如类数组，字符串，set 和 map</li></ul></li></ol> <h2 id="_12-js-模块化方案"><a href="#_12-js-模块化方案" class="header-anchor">#</a> 12 js 模块化方案</h2> <h3 id="_12-1-amd-和-cmd"><a href="#_12-1-amd-和-cmd" class="header-anchor">#</a> 12.1 AMD 和 CMD</h3> <ul><li>AMD 是 RequireJS 在推广过程中对模块定义的规范化而产出的。</li> <li>CMD 是 SeaJS 在推广过程中对模块定义的规范化而产出的。</li> <li>对于依赖的模块，AMD 可以提前执行，也可以延迟执行，CMD 则是延迟执行。</li> <li>AMD 推崇依赖前置，CMD 则推崇就近依赖。（可以说，CMD 就是个&quot;懒人&quot;）</li> <li>AMD 支持全局 require、局部 require，但是 CMD 则不支持全局 require，所以 CMD 没有全局 API 而 AMD 有。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// AMD  依赖前置</span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'./zty'</span><span class="token punctuation">,</span> <span class="token string">'./ty'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">zty<span class="token punctuation">,</span> ty</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  zty<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  ty<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// CMD</span>
<span class="token function">define</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">require<span class="token punctuation">,</span> exprots<span class="token punctuation">,</span> module</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> zty <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./zty'</span><span class="token punctuation">)</span>
  zty<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token comment">// 需要的时候才去require</span>
  <span class="token keyword">var</span> ty <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./ty'</span><span class="token punctuation">)</span>
  ty<span class="token punctuation">.</span><span class="token function">sayName</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="_12-1-commonjs"><a href="#_12-1-commonjs" class="header-anchor">#</a> 12.1 CommonJs</h3> <p>CommonJS 是为服务器提供的一种模块形式的优化，CommonJS 模块建议指定一个简单的用于声明模块服务器端的 API，并且不像 AMD 那样尝试去广泛的操心诸如 io，文件系统，约定以及更多的一揽子问题。它有以下特点：</p> <ul><li>主要运用在服务端 js，如 node</li> <li>全局对象：global</li> <li>一个文件就是一个模块，拥有单独的作用域，所有代码都运行在模块作用域，不会污染全局作用域；模块可以多次加载，但只会在第一次加载的时候运行一次，然后运行结果就被缓存了，以后再加载，就直接读取缓存结果；(你可以暴露一个时间戳来测试)</li> <li>模块的加载顺序，按照代码的出现顺序，</li> <li>同步加载</li> <li>通过 require 来加载模块：require 基本功能：读取并执行一个 JS 文件，然后返回该模块的 module.exports 对象，如果没有发现指定模块会报错</li> <li>通过 exports 和 module.exports 来暴露模块中的内容</li></ul> <p>那么 exports 和 module.exports 有什么区别呢？</p> <ul><li><p>模块内的 exports：为了方便，node 为每个模块提供一个 exports 变量，其指向 module.exports，相当于在模块头部加了这句话：var exports = module.exports，在对外输出时，可以给 module.exports 对象添加方法</p></li> <li><p>module.exports 方法还可以单独返回一个数据类型(String、Number、Object...)，而 exports 只能返回一个 Object 对象。所有的 exports 对象最终都是通过 module.exports 传递执行，因此可以更确切地说，exports 是给 module.exports 添加属性和方法。</p></li></ul> <h3 id="_12-2-es6-module"><a href="#_12-2-es6-module" class="header-anchor">#</a> 12.2 ES6 Module</h3> <p>ES6 模块化规范是 ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，其设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。并且 ES6 的模块自动采用严格模式，无论我们是否添加了在模块头部加上 &quot;use strict&quot; 。</p> <p>ES6 Module 常见的有四个命令，分别是</p> <ul><li>导出 export</li> <li>默认导出 export default</li> <li>导入 import</li> <li>重命名 as</li></ul> <p><strong>export：</strong></p> <ul><li>export 导出应该是一种接口或是理解为一种定义，而不应该是值</li> <li>export 导出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</li> <li>export 命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下面的 import 命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了 ES6 模块的设计初衷。</li></ul> <p><strong>export default：</strong></p> <p>本质上，export default 就是在 Module 上输出一个叫做 default 的变量或方法，和 export 完全不同，所以它后面不能跟变量声明语句，但表达式，function，class 除外。</p> <p><strong>import：</strong></p> <ul><li>import 命令输入的变量都是只读的，因为它的本质是输入接口。也就是说，不允许在加载模块的脚本里面，改写接口。</li> <li>对于 export 导出的接口应该使用 import { interface1 } 的方式</li> <li>对于 export default 导出的变量应该使用 import interface1 的方式</li> <li>import 命令具有提升效果，会提升到整个模块的头部，首先执行。</li> <li>如果多次重复执行同一句 import 语句，那么只会执行一次，而不会执行多次。</li></ul> <h3 id="_12-3-commonjs-和-es6-模块的区别"><a href="#_12-3-commonjs-和-es6-模块的区别" class="header-anchor">#</a> 12.3 CommonJS 和 ES6 模块的区别</h3> <ul><li>CommonJS 模块是运行时加载，ES6 Modules 是编译时输出接口</li> <li>CommonJS 输出是值的拷贝；ES6 Modules 输出的是值的引用，被输出模块的内部的改变会影响引用的改变</li> <li>CommonJs 导入的模块路径可以是一个表达式，因为它使用的是 require()方法；而 ES6 - Modules 只能是字符串</li> <li>CommonJS this 指向当前模块，ES6 Modules this 指向 undefined</li> <li>且 ES6 Modules 中没有这些顶层变量：arguments、require、module、exports、**filename、**dirname</li></ul> <h3 id="_12-4-umd"><a href="#_12-4-umd" class="header-anchor">#</a> 12.4 UMD</h3> <p>UMD 是为了让同一个代码模块在使用 CommonJs、CMD 甚至是 AMD 的项目中运行。为了实现兼容，所以有点“丑陋”。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">global<span class="token punctuation">,</span> factory</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> define <span class="token operator">===</span> <span class="token string">'function'</span> <span class="token operator">&amp;&amp;</span> define<span class="token punctuation">.</span>amd<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// AMD</span>
        <span class="token function">define</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'jquery'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> factory<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> exports <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token comment">// Node, CommonJS-like</span>
        module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'jquery'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        global<span class="token punctuation">.</span>returnExports <span class="token operator">=</span> <span class="token function">factory</span><span class="token punctuation">(</span>global<span class="token punctuation">.</span>jQuery<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> window <span class="token operator">!==</span> <span class="token string">&quot;undefined&quot;</span> <span class="token operator">?</span> window <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span> <span class="token parameter">window<span class="token punctuation">,</span> noGlobal</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>
   <span class="token comment">// methods</span>
      <span class="token operator">...</span>
   <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

</code></pre></div><h2 id="_13-浅拷贝和深拷贝"><a href="#_13-浅拷贝和深拷贝" class="header-anchor">#</a> 13 浅拷贝和深拷贝</h2> <p>简单来说，就是在拷贝复杂类型时，浅拷贝复制的是引用地址，深拷贝是拷贝一份新的属性。</p> <p>如何实现深拷贝：</p> <ol><li>通过 JSON 拷贝</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span><span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>虽然简单，但是有一些缺陷：</p> <ul><li>不能拷贝原型链上的属性</li> <li>对象的属性值是函数时，无法拷贝</li> <li>不能正确的处理 Date, 得到了 Date.toString()</li> <li>不能正确的处理 RegExp 类型的数据, 得到了 new Object()</li> <li>会忽略 symbol, undefined, Symbol</li></ul> <ol start="2"><li>Object.assign({}, target) 或 {...target}</li></ol> <p>优点：</p> <ul><li>可以解决 JSON 不能处理或是无法拷贝的问题 缺点是:</li> <li>只能深拷贝最顶上的一层</li> <li>不能拷贝原型链上的属性</li></ul> <ol start="3"><li>实现一个递归的深拷贝函数</li></ol> <p>优点：</p> <ul><li>可以解决 JSON 不能处理或是无法拷贝的问题</li> <li>可以获取原型链上的属性 缺点是:</li> <li>需要递归和逻辑较为复杂</li></ul> <p>下面是一个深拷贝的实现函数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> hash <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 递归拷贝</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">RegExp</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">RegExp</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Date</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> obj <span class="token comment">// 简单类型</span>

  <span class="token keyword">if</span> <span class="token punctuation">(</span>hash<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> hash<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token comment">// 循环引用</span>

  <span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">obj<span class="token punctuation">.</span>constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  hash<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> instance<span class="token punctuation">)</span>

  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// no-prototype-builtins</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      instance<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">dc</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> hash<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> instance
<span class="token punctuation">}</span>
</code></pre></div><h2 id="_14-js-应用"><a href="#_14-js-应用" class="header-anchor">#</a> 14 JS 应用</h2> <h3 id="_14-1-实现-promise-all-和-promise-race-的主要逻辑"><a href="#_14-1-实现-promise-all-和-promise-race-的主要逻辑" class="header-anchor">#</a> 14.1 实现 Promise.all 和 Promise.race 的主要逻辑</h3> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Promise</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">all</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> results <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment">// 结果数组</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> count <span class="token operator">=</span> arr<span class="token punctuation">.</span>length
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">//arr[i]的promise返回值可能是普通值</span>
      Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          results<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> data
          <span class="token operator">--</span>count
          <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span>results<span class="token punctuation">)</span>
            <span class="token keyword">return</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
          <span class="token keyword">return</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Promise</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">race</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">promises</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> promises<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>promises<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
          <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_14-2-防抖和节流"><a href="#_14-2-防抖和节流" class="header-anchor">#</a> 14.2 防抖和节流</h3> <p>防抖和节流是针对响应跟不上触发频率这类问题的两种解决方案。</p> <ul><li>函数防抖: debounce</li> <li>定义：多次触发事件后，事件处理函数只执行一次，并且是在触发操作结束时执行。</li> <li>函数节流: throttle</li> <li>定义：触发函数事件后，短时间间隔内无法连续调用，只有上一次函数执行后，过了规定的时间间隔，才能进行下一次的函数调用。。</li> <li>简单实现:</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>rest</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    timer <span class="token operator">&amp;&amp;</span> <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span>
    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> rest<span class="token punctuation">)</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">throttle</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> start
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>rest</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> now <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token operator">!</span>start <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>start <span class="token operator">=</span> now<span class="token punctuation">)</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">-</span> start <span class="token operator">&gt;=</span> delay<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> rest<span class="token punctuation">)</span>
      start <span class="token operator">=</span> now
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">throttle2</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> delay</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> timer
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>rest</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>timer<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> rest<span class="token punctuation">)</span>
        timer <span class="token operator">=</span> <span class="token keyword">null</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_14-3-原生-ajax"><a href="#_14-3-原生-ajax" class="header-anchor">#</a> 14.3 原生 ajax</h3> <ol><li>创建 xhr 实例</li> <li>open 链接(请求方法，url, 同步异步)</li> <li>设置请求参数</li> <li>监听 onreadystatechange 事件</li> <li>发送</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> xhr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
xhr<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'POST'</span><span class="token punctuation">,</span> url<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span>
xhr<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'Content-Type'</span><span class="token punctuation">,</span> <span class="token string">'application/x-www-form-urlencoded'</span><span class="token punctuation">)</span>
xhr<span class="token punctuation">.</span><span class="token function-variable function">onreadystatechange</span> <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// readyState == 4说明请求已完成</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>readyState <span class="token operator">==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">200</span> <span class="token operator">||</span> xhr<span class="token punctuation">.</span>status <span class="token operator">==</span> <span class="token number">304</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span>
      <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>xhr<span class="token punctuation">.</span>responseText<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
xhr<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="_14-4-柯里化"><a href="#_14-4-柯里化" class="header-anchor">#</a> 14.4 柯里化</h3> <p>柯里化（Currying）是把接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">curry</span><span class="token punctuation">(</span><span class="token parameter">fn<span class="token punctuation">,</span> <span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> args<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> fn<span class="token punctuation">.</span>length
    <span class="token operator">?</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>arguments</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">curry</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">,</span> <span class="token operator">...</span>arguments<span class="token punctuation">)</span>
    <span class="token operator">:</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_14-5-扁平化处理"><a href="#_14-5-扁平化处理" class="header-anchor">#</a> 14.5 扁平化处理</h3> <ol><li>数组的扁平化处理, 将多层的数组转成一维数组，例如将</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>

</code></pre></div><ul><li>使用 Array.prototype.flat(depth)。 depth 不能小于数组的深度</li></ul> <div class="language-js extra-class"><pre class="language-js"><code>arr<span class="token punctuation">.</span><span class="token function">flat</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
</code></pre></div><ul><li>遍历</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">flat1</span><span class="token punctuation">(</span><span class="token parameter">arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">some</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">item</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>item<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token operator">...</span>arr<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> arr
<span class="token punctuation">}</span>
</code></pre></div><ul><li>递归实现</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">flat2</span><span class="token punctuation">(</span><span class="token parameter">arr1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> arr1<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>
    <span class="token punctuation">(</span><span class="token parameter">acc<span class="token punctuation">,</span> val</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>
      Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span> <span class="token operator">?</span> acc<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span><span class="token function">flat2</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">:</span> acc<span class="token punctuation">.</span><span class="token function">concat</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ul><li>非递归</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">stackFlatten</span><span class="token punctuation">(</span><span class="token parameter">input</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>input<span class="token punctuation">]</span>
  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> next <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>next<span class="token punctuation">)</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>next<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res<span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><ol start="2"><li>对象的扁平化，只包含普通类型，数组和对象。例如</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
    num<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    arr<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span>
    obj<span class="token operator">:</span> <span class="token punctuation">{</span>
        name<span class="token operator">:</span> <span class="token string">'name'</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 偏平化后=&gt;</span>
<span class="token punctuation">{</span>
    num<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    arr<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
    arr<span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    obj<span class="token punctuation">.</span>name<span class="token operator">:</span> <span class="token string">'name'</span>
<span class="token punctuation">}</span>

</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">_typeof</span><span class="token punctuation">(</span><span class="token parameter">object</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> _toString <span class="token operator">=</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString
  <span class="token keyword">return</span> <span class="token function">_toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">flatten</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>obj<span class="token punctuation">)</span> <span class="token keyword">return</span>
  <span class="token keyword">let</span> res <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

  <span class="token keyword">function</span> <span class="token function">flat</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_typeof</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object Array]'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>value<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        res<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
        <span class="token keyword">return</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">flat</span><span class="token punctuation">(</span>key <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.[</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>k<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">]</span><span class="token template-punctuation string">`</span></span> <span class="token operator">:</span> k<span class="token punctuation">,</span> value<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">_typeof</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token string">'[object Object]'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        res<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
        <span class="token keyword">return</span>
      <span class="token punctuation">}</span>
      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">flat</span><span class="token punctuation">(</span>key <span class="token operator">?</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>k<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span> <span class="token operator">:</span> k<span class="token punctuation">,</span> value<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token function">flat</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> obj<span class="token punctuation">)</span>
  <span class="token keyword">return</span> res
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_14-6-判断两个对象相同"><a href="#_14-6-判断两个对象相同" class="header-anchor">#</a> 14.6 判断两个对象相同</h3> <p>判断两个对象相同，两个对象从表面上看没有任何不同。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">looseEqual</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span> b</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token operator">===</span> b<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">true</span>
  <span class="token keyword">const</span> isObjectA <span class="token operator">=</span> <span class="token function">isObject</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
  <span class="token keyword">const</span> isObjectB <span class="token operator">=</span> <span class="token function">isObject</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>isObjectA <span class="token operator">&amp;&amp;</span> isObjectB<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">try</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> isArrayA <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
      <span class="token keyword">const</span> isArrayB <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>isArrayA <span class="token operator">&amp;&amp;</span> isArrayB<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>
          a<span class="token punctuation">.</span>length <span class="token operator">===</span> b<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span>
          a<span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">e<span class="token punctuation">,</span> i</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">looseEqual</span><span class="token punctuation">(</span>e<span class="token punctuation">,</span> b<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>a <span class="token keyword">instanceof</span> <span class="token class-name">Date</span> <span class="token operator">&amp;&amp;</span> b <span class="token keyword">instanceof</span> <span class="token class-name">Date</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> a<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> b<span class="token punctuation">.</span><span class="token function">getTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isArrayA <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isArrayB<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> keysA <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
        <span class="token keyword">const</span> keysB <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
        <span class="token keyword">return</span> <span class="token punctuation">(</span>
          keysA<span class="token punctuation">.</span>length <span class="token operator">===</span> keysB<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span>
          keysA<span class="token punctuation">.</span><span class="token function">every</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">key</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">looseEqual</span><span class="token punctuation">(</span>a<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> b<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">)</span>
      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
        <span class="token comment">/* istanbul ignore next */</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">/* istanbul ignore next */</span>
      <span class="token keyword">return</span> <span class="token boolean">false</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>isObjectA <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>isObjectB<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">String</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token function">String</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token boolean">false</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><blockquote><p>答案来自 vue 源码 src/shared/util.js</p></blockquote> <h2 id="_15-use-strict-使用它的好处和坏处分别是什么"><a href="#_15-use-strict-使用它的好处和坏处分别是什么" class="header-anchor">#</a> 15 &quot;use strict&quot;;?使用它的好处和坏处分别是什么</h2> <p>在代码中出现表达式-<code>&quot;use strict&quot;</code>; 意味着代码按照严格模式解析，这种模式使得 Javascript 在更严格的条件下运行。<br> <em>好处</em>：</p> <ul><li>消除 Javascript 语法的一些不合理、不严谨之处，减少一些怪异行为;</li> <li>消除代码运行的一些不安全之处，保证代码运行的安全；</li> <li>提高编译器效率，增加运行速度；</li> <li>为未来新版本的 Javascript 做好铺垫。</li></ul> <p><em>坏处：</em></p> <ul><li>同样的代码，在&quot;严格模式&quot;中，可能会有不一样的运行结果；</li> <li>一些在&quot;正常模式&quot;下可以运行的语句，在&quot;严格模式&quot;下将不能运行。</li></ul></div> <div data-v-a14a39de></div></div></div></div></div> <div cclass="ag-footer-warp" data-v-1895eed2><div class="ag-footer" data-v-3078f227 data-v-1895eed2><div data-v-3078f227>余 年</div> <div class="supporting" data-v-3078f227>-</div> <div class="supporting" data-v-3078f227>距离2022年还剩下  天</div></div></div></div><div class="global-ui"></div></div>
    <script src="/Agan-blog/assets/js/app.3c2129f2.js" defer></script><script src="/Agan-blog/assets/js/2.0d86c6dd.js" defer></script><script src="/Agan-blog/assets/js/53.a56229c5.js" defer></script>
  </body>
</html>
