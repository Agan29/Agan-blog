(window.webpackJsonp=window.webpackJsonp||[]).push([[26],{431:function(v,_,e){"use strict";e.r(_);var o=e(42),c=Object(o.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"vue3"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue3"}},[v._v("#")]),v._v(" Vue3")]),v._v(" "),e("h2",{attrs:{id:"vue2-0和vue3-0的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue2-0和vue3-0的区别"}},[v._v("#")]),v._v(" Vue2.0和Vue3.0的区别")]),v._v(" "),e("ol",[e("li",[v._v("重构响应式系统，使用Proxy替换"),e("code",[v._v("Object.defineProperty")]),v._v("，使用Proxy优势：\n"),e("ul",[e("li",[v._v("可直接监听数组类型的数据变化")]),v._v(" "),e("li",[v._v("监听的目标为对象本身，不需要像"),e("code",[v._v("Object.defineProperty")]),v._v("一样遍历每个属性，有一定的性能提升")]),v._v(" "),e("li",[v._v("可拦截"),e("code",[v._v("apply")]),v._v("、"),e("code",[v._v("ownKeys")]),v._v("、"),e("code",[v._v("has")]),v._v("等13种方法，而"),e("code",[v._v("Object.defineProperty")]),v._v("不行")]),v._v(" "),e("li",[v._v("直接实现对象属性的新增/删除")])])]),v._v(" "),e("li",[v._v("新增"),e("code",[v._v("Composition API")]),v._v("，更好的逻辑复用和代码组织")]),v._v(" "),e("li",[v._v("重构 "),e("code",[v._v("Virtual DOM")]),v._v(" "),e("ul",[e("li",[v._v("模板编译时的优化，将一些静态节点编译成常量")]),v._v(" "),e("li",[e("code",[v._v("slot")]),v._v("优化，将"),e("code",[v._v("slot")]),v._v("编译为"),e("code",[v._v("lazy")]),v._v("函数，将"),e("code",[v._v("slot")]),v._v("的渲染的决定权交给子组件")]),v._v(" "),e("li",[v._v("模板 中内联事件的提取并重用（原本每次渲染都重新生成内联函数）")])])]),v._v(" "),e("li",[v._v("代码结构调整，更便于"),e("code",[v._v("Tree shaking")]),v._v("，使得体积更小")]),v._v(" "),e("li",[v._v("使用"),e("code",[v._v("Typescript")]),v._v("替换"),e("code",[v._v("Flow")])])]),v._v(" "),e("h2",{attrs:{id:"为什么要新增composition-api-它能解决什么问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么要新增composition-api-它能解决什么问题"}},[v._v("#")]),v._v(" 为什么要新增"),e("code",[v._v("Composition API")]),v._v("，它能解决什么问题")]),v._v(" "),e("p",[e("code",[v._v("Vue2.0")]),v._v("中，随着功能的增加，组件变得越来越复杂，越来越难维护，而难以维护的根本原因是"),e("code",[v._v("Vue")]),v._v("的"),e("code",[v._v("API")]),v._v("设计迫使开发者使用"),e("code",[v._v("watch")]),v._v("，computed，"),e("code",[v._v("methods")]),v._v("选项组织代码，而不是实际的业务逻辑。"),e("br"),v._v("\n另外Vue2.0缺少一种较为简洁的低成本的机制来完成逻辑复用，虽然可以"),e("code",[v._v("minxis")]),v._v("完成逻辑复用，但是当"),e("code",[v._v("mixin")]),v._v("变多的时候，会使得难以找到对应的"),e("code",[v._v("data")]),v._v("、"),e("code",[v._v("computed")]),v._v("或者"),e("code",[v._v("method")]),v._v("来源于哪个mixin，使得类型推断难以进行。"),e("br"),v._v("\n所以"),e("code",[v._v("Composition API")]),v._v("的出现，主要是也是为了解决"),e("code",[v._v("Option API")]),v._v("带来的问题，第一个是代码组织问题，"),e("code",[v._v("Compostion API")]),v._v("可以让开发者根据业务逻辑组织自己的代码，让代码具备更好的可读性和可扩展性，也就是说当下一个开发者接触这一段不是他自己写的代码时，他可以更好的利用代码的组织反推出实际的业务逻辑，或者根据业务逻辑更好的理解代码。"),e("br"),v._v("\n第二个是实现代码的逻辑提取与复用，当然"),e("code",[v._v("mixin")]),v._v("也可以实现逻辑提取与复用，但是像前面所说的，多个"),e("code",[v._v("mixin")]),v._v("作用在同一个组件时，很难看出property是来源于哪个"),e("code",[v._v("mixin")]),v._v("，来源不清楚，另外，多个"),e("code",[v._v("mixin")]),v._v("的"),e("code",[v._v("property")]),v._v("存在变量命名冲突的风险。而"),e("code",[v._v("Composition API")]),v._v("刚好解决了这两个问题。")]),v._v(" "),e("h2",{attrs:{id:"在vue3-0优雅的使用v-model"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在vue3-0优雅的使用v-model"}},[v._v("#")]),v._v(" 在Vue3.0优雅的使用v-model")]),v._v(" "),e("p",[v._v("在"),e("code",[v._v("Vue2.0")]),v._v("中如何实现双向数据绑定一种是"),e("code",[v._v("v-model")]),v._v("，另一种是"),e("code",[v._v(".sync")]),v._v("。因为一个组件只能用于一个"),e("code",[v._v("v-model")]),v._v("，但是有的组件需要有多个可以双向响应的数据，所以就出现了"),e("code",[v._v(".sync")]),v._v("。在"),e("code",[v._v("Vue3.0")]),v._v("中为了实现统一，实现了让一个组件可以拥有多个"),e("code",[v._v("v-model")]),v._v("，同时删除掉了"),e("code",[v._v(".sync")]),v._v("。在vue3.0中，"),e("code",[v._v("v-model")]),v._v("后面需要跟一个"),e("code",[v._v("modelValue")]),v._v("，即要双向绑定的属性名，"),e("code",[v._v("Vue3.0")]),v._v("就是通过给不同的"),e("code",[v._v("v-model")]),v._v("指定不同的"),e("code",[v._v("modelValue")]),v._v("来实现多个"),e("code",[v._v("v-model")]),v._v("。")]),v._v(" "),e("blockquote",[e("p",[v._v("参考地址: "),e("a",{attrs:{href:"https://v3.vuejs.org/guide/migration/v-model.html#overview",target:"_blank",rel:"noopener noreferrer"}},[v._v("https://v3.vuejs.org/guide/migration/v-model.html#overview"),e("OutboundLink")],1)])]),v._v(" "),e("h2",{attrs:{id:"ssr是什么-原理是什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#ssr是什么-原理是什么"}},[v._v("#")]),v._v(" SSR是什么，原理是什么？")]),v._v(" "),e("p",[v._v("在客户端请求服务器的时候，服务器到数据库中获取到相关的数据，并且在服务器内部将"),e("code",[v._v("Vue")]),v._v("组件渲染成"),e("code",[v._v("HTML")]),v._v("，并且将数据、"),e("code",[v._v("HTML")]),v._v("一并返回给客户端，这个在服务器将数据和组件转化为HTML的过程，叫做服务端渲染"),e("code",[v._v("SSR")]),v._v("。")]),v._v(" "),e("p",[v._v("而当客户端拿到服务器渲染的"),e("code",[v._v("HTML")]),v._v("和数据之后，由于数据已经有了，客户端不需要再一次请求数据，而只需要将数据同步到组件或者"),e("code",[v._v("Vuex")]),v._v("内部即可。除了数据意外，"),e("code",[v._v("HTML")]),v._v("也结构已经有了，客户端在渲染组件的时候，也只需要将"),e("code",[v._v("HTML")]),v._v("的"),e("code",[v._v("DOM")]),v._v("节点映射到"),e("code",[v._v("Virtual DOM")]),v._v("即可，不需要重新创建"),e("code",[v._v("DOM")]),v._v("节点，这个将数据和"),e("code",[v._v("HTML")]),v._v("同步的过程，又叫做客户端激活。")]),v._v(" "),e("p",[e("strong",[v._v("使用SSR的好处：")])]),v._v(" "),e("ul",[e("li",[e("p",[v._v("**有利于"),e("code",[v._v("SEO")]),v._v("：**其实就是有利于爬虫来爬你的页面，因为部分页面爬虫是不支持执行"),e("code",[v._v("JavaScript")]),v._v("的，这种不支持执行"),e("code",[v._v("JavaScript")]),v._v("的爬虫抓取到的非SSR的页面会是一个空的"),e("code",[v._v("HTML")]),v._v("页面，而有了"),e("code",[v._v("SSR")]),v._v("以后，这些爬虫就可以获取到完整的"),e("code",[v._v("HTML")]),v._v("结构的数据，进而收录到搜索引擎中。")])]),v._v(" "),e("li",[e("p",[v._v("**白屏时间更短：**相对于客户端渲染，服务端渲染在浏览器请求"),e("code",[v._v("URL")]),v._v("之后已经得到了一个带有数据的"),e("code",[v._v("HTML")]),v._v("文本，浏览器只需要解析"),e("code",[v._v("HTML")]),v._v("，直接构建"),e("code",[v._v("DOM")]),v._v("树就可以。而客户端渲染，需要先得到一个空的"),e("code",[v._v("HTML")]),v._v("页面，这个时候页面已经进入白屏，之后还需要经过加载并执行 "),e("code",[v._v("JavaScript")]),v._v("、请求后端服务器获取数据、"),e("code",[v._v("JavaScript")]),v._v(" 渲染页面几个过程才可以看到最后的页面。特别是在复杂应用中，由于需要加载 "),e("code",[v._v("JavaScript")]),v._v(" 脚本，越是复杂的应用，需要加载的 "),e("code",[v._v("JavaScript")]),v._v(" 脚本就越多、越大，这会导致应用的首屏加载时间非常长，进而降低了体验感。")])])]),v._v(" "),e("h2",{attrs:{id:"composition-api与react-hook的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#composition-api与react-hook的区别"}},[v._v("#")]),v._v(" Composition API与React Hook的区别")]),v._v(" "),e("p",[v._v("从"),e("code",[v._v("React Hook")]),v._v("的实现角度看，"),e("code",[v._v("React Hook")]),v._v("是根据"),e("code",[v._v("useState")]),v._v("调用的顺序来确定下一次重渲染时的"),e("code",[v._v("state")]),v._v("是来源于哪个"),e("code",[v._v("useState")]),v._v("，所以出现了以下限制")]),v._v(" "),e("ul",[e("li",[v._v("不能在循环、条件、嵌套函数中调用Hook[^Hook]")]),v._v(" "),e("li",[v._v("必须确保总是在你的React函数的顶层调用Hook")]),v._v(" "),e("li",[e("code",[v._v("useEffect")]),v._v("、"),e("code",[v._v("useMemo")]),v._v("等函数必须手动确定依赖关系")])]),v._v(" "),e("p",[v._v("而"),e("code",[v._v("Composition API")]),v._v("是基于"),e("code",[v._v("Vue")]),v._v("的响应式系统实现的，与"),e("code",[v._v("React Hook")]),v._v("的相比声明在"),e("code",[v._v("setup")]),v._v("函数内，一次组件实例化只调用一次"),e("code",[v._v("setup")]),v._v("，而"),e("code",[v._v("React Hook")]),v._v("每次重渲染都需要调用"),e("code",[v._v("Hook")]),v._v("，使得"),e("code",[v._v("React")]),v._v("的"),e("code",[v._v("GC")]),v._v("比"),e("code",[v._v("Vue")]),v._v("更有压力，性能也相对于"),e("code",[v._v("Vue")]),v._v("来说也较慢;")]),v._v(" "),e("p",[e("code",[v._v("Compositon API")]),v._v("的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用;")]),v._v(" "),e("p",[v._v("响应式系统自动实现了依赖收集，进而组件的部分的性能优化由"),e("code",[v._v("Vue")]),v._v("内部自己完成，而"),e("code",[v._v("React Hook")]),v._v("需要手动传入依赖，而且必须必须保证依赖的顺序，让"),e("code",[v._v("useEffect")]),v._v("、"),e("code",[v._v("useMemo")]),v._v("等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。")]),v._v(" "),e("p",[v._v("虽然"),e("code",[v._v("Compositon API")]),v._v("看起来比"),e("code",[v._v("React Hook")]),v._v("好用，但是其设计思想也是借鉴"),e("code",[v._v("React Hook")]),v._v("的。")]),v._v(" "),e("p",[v._v("[^Hook]:  React 靠的是 Hook 调用的顺序,知道哪个 state 对应哪个 useState,只要 Hook 的调用顺序在多次渲染之间保持一致，React 就能正确地将内部 state 和对应的 Hook 进行关联 "),e("a",{attrs:{href:"https://zh-hans.reactjs.org/docs/hooks-rules.html#explanation",target:"_blank",rel:"noopener noreferrer"}},[v._v("Hook rules"),e("OutboundLink")],1)])])}),[],!1,null,null,null);_.default=c.exports}}]);