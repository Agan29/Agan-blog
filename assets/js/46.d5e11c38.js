(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{419:function(v,_,s){"use strict";s.r(_);var e=s(42),c=Object(e.a)({},(function(){var v=this,_=v.$createElement,s=v._self._c||_;return s("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[s("h1",{attrs:{id:"js-css-顺序对前端优化影响"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js-css-顺序对前端优化影响"}},[v._v("#")]),v._v(" js css 顺序对前端优化影响")]),v._v(" "),s("p",[v._v("渲染树的构成必须要 "),s("code",[v._v("DOM")]),v._v(" 树和 "),s("code",[v._v("CSSOM")]),v._v(" 树的，所以尽快的构建 "),s("code",[v._v("CSSOM")]),v._v(" 树是一个重要的优化手段，如果 "),s("code",[v._v("css")]),v._v(" 文件放在尾部，那么整个过程就是一个串行的过程先解析了 "),s("code",[v._v("dom")]),v._v("，再去解析 "),s("code",[v._v("css")]),v._v("。所以 "),s("code",[v._v("css")]),v._v(" 我们一般都是放在头部，这样 "),s("code",[v._v("DOM")]),v._v(" 树和 "),s("code",[v._v("CSSOM")]),v._v(" 树的构建是同步进行的。")]),v._v(" "),s("p",[v._v("再来看 "),s("code",[v._v("js")]),v._v("，因为 "),s("code",[v._v("js")]),v._v(" 的运行会阻止 DOM 树的渲染的，所以一旦我们的 "),s("code",[v._v("js")]),v._v(" 放在了头部，而且也没有异步加载这些操作的话，"),s("code",[v._v("js")]),v._v(" 一旦一直在运行，"),s("code",[v._v("DOM")]),v._v(" 树就一直构建不出来，那么页面就会一直出现白屏界面，所以一般我们会把 "),s("code",[v._v("js")]),v._v(" 文件放在尾部。"),s("br"),v._v("\n当然放到尾部也不是就没有问题了，只是问题相对较小，放到尾部的 "),s("code",[v._v("js")]),v._v(" 文件如果过大，运行时间长，代码加载时，就会有大量耗时的操作造成页面不可点击，这就是另一个问题，但这肯定比白屏要好，白屏是什么页面都没有，这种是页面有了只是操作不流畅。"),s("br"),v._v(" "),s("code",[v._v("js")]),v._v(" 脚本放在尾部还有一个原因，有时候 "),s("code",[v._v("js")]),v._v(" 代码会有操作 "),s("code",[v._v("dom")]),v._v(" 节点的情况，如果放在头部执行，"),s("code",[v._v("DOM")]),v._v("树还没有构建，拿不到 "),s("code",[v._v("DOM")]),v._v(" 节点但是你又去使用就会出现报错情况，错误没处理好的话页面会直接崩掉")])])}),[],!1,null,null,null);_.default=c.exports}}]);