(window.webpackJsonp=window.webpackJsonp||[]).push([[50],{413:function(t,e,a){"use strict";a.r(e);var s=a(42),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"事件循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件循环"}},[t._v("#")]),t._v(" 事件循环")]),t._v(" "),a("h2",{attrs:{id:"event-loop-模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#event-loop-模型"}},[t._v("#")]),t._v(" Event Loop 模型")]),t._v(" "),a("p",[t._v("JavaScript 用来解决由于单线程阻塞造成执行效率低下的机制，也就是我们常说的"),a("code",[t._v("异步")]),t._v("的基石。在不同的 JavaScript 宿主环境，"),a("code",[t._v("Event Loop")]),t._v("有着不同的模型。")]),t._v(" "),a("h2",{attrs:{id:"任务队列"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#任务队列"}},[t._v("#")]),t._v(" 任务队列")]),t._v(" "),a("p",[t._v("任务队列是用来存放异步任务的回调，是一种"),a("strong",[t._v("先进先出")]),t._v("的线性结构。由于异步任务之间并不相同，任务队列也由多个队列组成。")]),t._v(" "),a("h3",{attrs:{id:"宏任务队列-microtask-queue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#宏任务队列-microtask-queue"}},[t._v("#")]),t._v(" 宏任务队列（microtask queue）")]),t._v(" "),a("ul",[a("li",[t._v("setTimeout/setTimeout")]),t._v(" "),a("li",[t._v("setImmediate")]),t._v(" "),a("li",[t._v("requestAnimationFrame")]),t._v(" "),a("li",[t._v("I/O")]),t._v(" "),a("li",[t._v("UI rendering (浏览器独有)")])]),t._v(" "),a("h3",{attrs:{id:"微任务队列-microtask-queue"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#微任务队列-microtask-queue"}},[t._v("#")]),t._v(" 微任务队列（microtask queue）")]),t._v(" "),a("ul",[a("li",[t._v("process.nextTick (Node 独有)")]),t._v(" "),a("li",[t._v("Promise")]),t._v(" "),a("li",[t._v("Object.observe")]),t._v(" "),a("li",[t._v("MutationObserver")])]),t._v(" "),a("p",[t._v("当满足执行条件时，task 和 microtask 会被放入各自的队列中，等待放入执行线程执行，我们把这两个队列称为 Task Queue(也叫 Macrotask Queue)和 Microtask Queue。")]),t._v(" "),a("h2",{attrs:{id:"浏览器环境下-事件循环模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#浏览器环境下-事件循环模型"}},[t._v("#")]),t._v(" 浏览器环境下 事件循环模型")]),t._v(" "),a("ol",[a("li",[t._v("执行 script 同步代码")]),t._v(" "),a("li",[t._v("执行栈为空")]),t._v(" "),a("li",[t._v("从微任务队列（microtask queue）中取出队首的回调任务，放入调用栈中执行")]),t._v(" "),a("li",[t._v("继续取出微任务队列队首的任务，放入调用栈中执行，以此类推，直到直到把微任务队列中的所有任务都执行完毕")]),t._v(" "),a("li",[t._v("取出宏任务队列（macrotask queue）中位于队首的任务，放入调用栈中执行")]),t._v(" "),a("li",[t._v("重复 2-5 步骤")])]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/zukunft/MDImage/raw/master/img/20200902000116.png",alt:"浏览器中event loop流程图"}})]),t._v(" "),a("h2",{attrs:{id:"中的事件循环"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#中的事件循环"}},[t._v("#")]),t._v(" 中的事件循环")]),t._v(" "),a("p",[t._v("在 node 中，事件循环表现出的状态与浏览器中大致相同。不同的是 node 中有一套自己的模型。node 中事件循环的实现是依靠的 libuv 引擎。我们知道 node 选择 chrome v8 引擎作为 js 解释器，v8 引擎将 js 代码分析后去调用对应的 node api，而这些 api 最后则由 libuv 引擎驱动，执行对应的任务，并把不同的事件放在不同的队列中等待主线程执行。 因此实际上 node 中的事件循环存在于 libuv 引擎中。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/zukunft/MDImage/raw/master/img/20200902000232.png",alt:"事件循环"}})]),t._v(" "),a("h3",{attrs:{id:"事件循环模型"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事件循环模型"}},[t._v("#")]),t._v(" 事件循环模型")]),t._v(" "),a("p",[t._v("NodeJS 的 Event Loop 中，执行宏队列的回调任务有 6 个阶段，如下图：")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://gitee.com/zukunft/MDImage/raw/master/img/20200902000248.png",alt:"事件循环模型"}})])])}),[],!1,null,null,null);e.default=r.exports}}]);