(window.webpackJsonp=window.webpackJsonp||[]).push([[43],{422:function(v,_,e){"use strict";e.r(_);var o=e(42),c=Object(o.a)({},(function(){var v=this,_=v.$createElement,e=v._self._c||_;return e("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[e("h1",{attrs:{id:"在浏览器上输入-url-之后的流程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#在浏览器上输入-url-之后的流程"}},[v._v("#")]),v._v(" 在浏览器上输入 url 之后的流程")]),v._v(" "),e("p",[v._v("我会大致上分成 获取资源 和 页面渲染 两个阶段。")]),v._v(" "),e("h2",{attrs:{id:"阶段-1-获取资源"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#阶段-1-获取资源"}},[v._v("#")]),v._v(" 阶段 1 获取资源")]),v._v(" "),e("ol",[e("li",[v._v("进行 "),e("code",[v._v("url")]),v._v(" 解析,查找 "),e("code",[v._v("url")]),v._v(" 对应服务器的 "),e("code",[v._v("IP")]),v._v(", 如果没有在缓存中找到，则通过 "),e("code",[v._v("DNS")]),v._v(" 系统进行 "),e("code",[v._v("IP")]),v._v(" 查找")]),v._v(" "),e("li",[v._v("根据 "),e("code",[v._v("IP")]),v._v(" 就可以找到服务器,然后浏览器和服务器会进行 "),e("code",[v._v("TCP")]),v._v(" 三次握手建立连接")]),v._v(" "),e("li",[v._v("建立 "),e("code",[v._v("TCP")]),v._v(" 连接,此时是 "),e("code",[v._v("https")]),v._v(" 的话，还会建立 "),e("code",[v._v("TLS")]),v._v(" 连接以及协商加密算法,之后发起 "),e("code",[v._v("http/https")]),v._v(" 请求(http 和 https 的区别)")]),v._v(" "),e("li",[v._v("连接建立之后浏览器开始发送请求获取文件，此时这里还会出现一种情况就是缓存，建立连接后是走缓存还是直接重新获取，需要看后台设置(浏览器缓存机制),直接获取或者通过缓存获取文件;")]),v._v(" "),e("li",[v._v("浏览器解析 html")])]),v._v(" "),e("h2",{attrs:{id:"阶段-2-页面渲染"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#阶段-2-页面渲染"}},[v._v("#")]),v._v(" 阶段 2 页面渲染")]),v._v(" "),e("ol",[e("li",[v._v("首先获取 "),e("code",[v._v("html")]),v._v(" 文件，构建 "),e("code",[v._v("DOM")]),v._v(" 树,边下载边解析,解析到 "),e("code",[v._v("html")]),v._v(" 头部时候，又会出现一种问题，"),e("code",[v._v("css,js")]),v._v(" 放到哪里了？不同的位置会造成渲染的不同，此时就会出现另一个需要关注的问题("),e("code",[v._v("css,js")]),v._v(" 位置应该放哪里?为什么),先按照正确的位置来说明(css 放头部,js 放尾部);")]),v._v(" "),e("li",[v._v("下载 "),e("code",[v._v("css")]),v._v(" "),e("code",[v._v("文件，css")]),v._v(" 文件也是一边下载一边解析的,构建的是 "),e("code",[v._v("CSSOM")]),v._v(" 树,当 "),e("code",[v._v("DOM")]),v._v(" 树和 "),e("code",[v._v("CSSOM")]),v._v(" 树全部构建完之后(互不影响)")]),v._v(" "),e("li",[v._v("生成 "),e("code",[v._v("CSSOM")]),v._v(" 树和 "),e("code",[v._v("DOM")]),v._v(" 树（互不影响），但 "),e("code",[v._v("script")]),v._v(" 标签的加载阻塞 "),e("code",[v._v("DOM")]),v._v(" 树的构建")]),v._v(" "),e("li",[v._v("浏览器会把 "),e("code",[v._v("DOM")]),v._v(" 树和 "),e("code",[v._v("CSSOM")]),v._v(" 树构建成渲染树，"),e("code",[v._v("css")]),v._v(" 文件则会阻塞渲染树的构建,构建渲染树的时候还做了以下事情\n"),e("ol",[e("li",[v._v("样式计算,"),e("code",[v._v("DOM")]),v._v(" 树和 "),e("code",[v._v("CSSOM")]),v._v(" 树有了之后，浏览器开始样式计算，主要是为 "),e("code",[v._v("DOM")]),v._v(" 树上的节点找到对应的样式")]),v._v(" "),e("li",[v._v("构建布局树 "),e("code",[v._v("layout")]),v._v("，样式计算完之后就开始构建布局树。主要是为 "),e("code",[v._v("DOM")]),v._v(' 树上的节点找到页面上对应位置以及一些"'),e("code",[v._v("display:none")]),v._v('"元素的隐藏。')]),v._v(" "),e("li",[v._v("构建分层树，布局树完成后浏览器还需要建立分层树，主要是为了满足滚动条，"),e("code",[v._v("z-index，position")]),v._v(" 这些复杂的分层操作")]),v._v(" "),e("li",[v._v("将分层树图块化，利用光栅找到视图窗口下的对应的位图。主要是因为一个页面可能有几屏那么长，一下渲染出来比较浪费，所以浏览器会找到视图窗口对应的图块，将这部分的图块进行渲染")])])]),v._v(" "),e("li",[v._v("paint,最终渲染进程将整个页面渲染出来，在渲染的过程中会还出现重排和重绘，这也是比较爱问的问题(重排重绘为什么会影响渲染，如何避免?)")])])])}),[],!1,null,null,null);_.default=c.exports}}]);