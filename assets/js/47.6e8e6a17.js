(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{417:function(e,v,_){"use strict";_.r(v);var c=_(42),a=Object(c.a)({},(function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"浏览器缓存机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#浏览器缓存机制"}},[e._v("#")]),e._v(" 浏览器缓存机制")]),e._v(" "),_("p",[e._v("我们经常说的浏览器缓存有两种，一种是强制缓存，一种是协商缓存，因为下面有具体实现讲解，所以这里就说一下概念")]),e._v(" "),_("ul",[_("li",[e._v("协商缓存"),_("br"),e._v("\n协商缓存意思是文件已经被缓存了，但是否从缓存中读取是需要和服务器进行协商，具体如何协商要看请求头/响应头的字段设置，下面会说到。需要注意的是协商缓存还是发了请求的")]),e._v(" "),_("li",[e._v("强制缓存"),_("br"),e._v("\n强制缓存就是文件直接从缓存中获取，不需要发送请求")])]),e._v(" "),_("h2",{attrs:{id:"缓存实现"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存实现"}},[e._v("#")]),e._v(" 缓存实现")]),e._v(" "),_("h3",{attrs:{id:"强制缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#强制缓存"}},[e._v("#")]),e._v(" 强制缓存")]),e._v(" "),_("p",[e._v("强制缓存在 "),_("code",[e._v("http1.0")]),e._v(" 的时候用的是 "),_("code",[e._v("Expires")]),e._v("，是响应头里面的一个字段表示的是文件过期时间。是一个绝对时间，正因为是绝对时间所以在某些情况下，服务器的时区和浏览器时区不一致的时候就会导致缓存失效。为了解决这个问题，"),_("code",[e._v("HTPP1.1")]),e._v(" 引入了一个新的响应头 "),_("code",[e._v("cache-control")]),e._v(" 它的可选值如下")]),e._v(" "),_("h4",{attrs:{id:"cache-control"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[e._v("#")]),e._v(" cache-control")]),e._v(" "),_("p",[_("code",[e._v("max-age")]),e._v(": 缓存过期时间，是一个相对时间"),_("br"),e._v(" "),_("code",[e._v("public")]),e._v(": 表示客户端和代理服务器都会缓存"),_("br"),e._v(" "),_("code",[e._v("private")]),e._v(": 表示只在客户端缓存"),_("br"),e._v(" "),_("code",[e._v("no-cache")]),e._v(": 协商缓存标识符，表示文件会被缓存但是需要和服务器协商"),_("br"),e._v(" "),_("code",[e._v("no-store")]),e._v(": 表示文件不会被缓存")]),e._v(" "),_("p",[_("code",[e._v("HTTP1.1")]),e._v(" 利用的就是 "),_("code",[e._v("max-age:600")]),e._v(" 来强制缓存，因为是相对时间，所以不会出现 "),_("code",[e._v("Expires")]),e._v(" 问题")]),e._v(" "),_("h3",{attrs:{id:"协商缓存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[e._v("#")]),e._v(" 协商缓存")]),e._v(" "),_("p",[e._v("协商缓存是利用 "),_("code",[e._v("Last-Modified/if-Modified-Since")]),e._v(","),_("code",[e._v("Etag/if-None-Match")]),e._v(" 这两对请求、响应头。")]),e._v(" "),_("h4",{attrs:{id:"last-modified-if-modified-since"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#last-modified-if-modified-since"}},[e._v("#")]),e._v(" Last-Modified/if-Modified-Since")]),e._v(" "),_("p",[e._v("浏览器第一次发送请求获取文件缓存下来，服务器响应头返回一个 "),_("code",[e._v("if-Modified-Since")]),e._v("，记录被改动的时间"),_("br"),e._v("\n浏览器第二次发送请求的时候会带上一个 "),_("code",[e._v("Last-Modified")]),e._v(" 请求头，时间就是 "),_("code",[e._v("if-Modified-Since")]),e._v(" 返回的值。然后服务器拿到这个字段和自己内部设置的时间进行对比，时间相同表示没有修改，就直接返回 "),_("code",[e._v("304")]),e._v(" 从缓存里面获取文件")]),e._v(" "),_("h4",{attrs:{id:"etag-if-none-match"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#etag-if-none-match"}},[e._v("#")]),e._v(" Etag/If-None-Match")]),e._v(" "),_("p",[e._v("由于 "),_("code",[e._v("Last-Modified")]),e._v(" 的时间粒度是秒，有的文件在 1s 内可能被改动多次。这种方式在这种特殊情况下还是会失效，所以"),_("code",[e._v("HTTP1.1")]),e._v("又引入了 "),_("code",[e._v("Etag")]),e._v(' 字段。这个字段是根据文件内容生成一个标记符比如"W/"5f9583bd-10a8""，然后再和 '),_("code",[e._v("If-None-Match")]),e._v(" 进行对比就能更准确的知道文件有没有被改动过")]),e._v(" "),_("h2",{attrs:{id:"缓存在哪里"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存在哪里"}},[e._v("#")]),e._v(" 缓存在哪里")]),e._v(" "),_("p",[e._v("知道了缓存方式和实现，再来说一下缓存存在哪个地方，我们打开掘金可以看到如下的信息"),_("br"),e._v("\n。缓存的来源有两个地方 "),_("code",[e._v("from dist cache")]),e._v(","),_("code",[e._v("from memeory cache")])]),e._v(" "),_("h3",{attrs:{id:"form-memory-cache"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#form-memory-cache"}},[e._v("#")]),e._v(" form memory cache")]),e._v(" "),_("p",[e._v("这个是缓存在内存里面，优点是快速，但是具有时效性，当关闭 "),_("code",[e._v("tab")]),e._v(" 时候缓存就会失效。")]),e._v(" "),_("h3",{attrs:{id:"from-dist-cache"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#from-dist-cache"}},[e._v("#")]),e._v(" from dist cache")]),e._v(" "),_("p",[e._v("这个是缓存在磁盘里面，虽然慢但是还是比请求快，优点是缓存可以一直被保留，即使关闭 "),_("code",[e._v("tab")]),e._v(" 页，也会一直存在"),_("br"),e._v("\n何时缓存在"),_("code",[e._v("memory")]),e._v(",合适缓存在"),_("code",[e._v("dist")]),e._v("？"),_("br"),e._v("\n这个问题网上很少找的到标准答案，大家一致的说法是"),_("code",[e._v("js")]),e._v(",图片文件浏览器会自动保存在"),_("code",[e._v("memory")]),e._v("中，"),_("code",[e._v("css")]),e._v("文件因为不常修改保存在dist里面，我们可以打开掘金网站，很大一部分文件都是按照这个规则来的，但是也有少数js文件也是缓存在dist里面。所以他的存放机制到底是什么样了？一个知乎的回答可以给我们提供思路，下面引用一个知乎回答者一段话")]),e._v(" "),_("blockquote",[_("ul",[_("li",[e._v("第一个现象(以图片为例)：访问-> 200 -> 退出浏览器再进来-> 200(from disk cache) -> 刷新 -> 200(from memory cache)。总结: 会不会是chrome很聪明的判断既然已经从disk拿来了， 第二次就内存拿吧 快。（笑哭)")]),e._v(" "),_("li",[e._v("第二个现象(以图片为例)：只要图片是"),_("code",[e._v("base64")]),e._v(" 我看都是"),_("code",[e._v("from memroy cache")]),e._v("。 总结: 解析渲染图片这么费劲的事情，还是做一次然后放到内存吧。 用的时候直接拿")]),e._v(" "),_("li",[e._v("第三个现象(以js css为例)：个人在做静态测试的发现，大型的js css文件都是直接"),_("code",[e._v("disk cache")]),e._v("。结: chrome会不会说 我去 你这么大太占地方了。 你就去硬盘里呆着吧。 慢就慢点吧。")]),e._v(" "),_("li",[e._v("第四个现象：隐私模式下，几乎都是 "),_("code",[e._v("from memroy cache")]),e._v("。总结: 隐私模式 是吧。 我不能暴露你东西，还是放到内存吧。 你关，我死。")])])]),e._v(" "),_("p",[e._v("上面几点是虽然很幽默，但是却可以从中找到一部分答案，但是我觉得另一个知乎回答我更赞同")]),e._v(" "),_("blockquote",[_("p",[e._v("浏览器运行的时候也是由几个进程协作的，所以操作系统为了节省内存，会把一部分内存里的资源交换回磁盘的交换区，当然交换是有策略的，比如最常用的就是LRU。"),_("br"),e._v("\n什么时候存dist，什么时候存memoey都是在浏览器控制下的，memory不够了可能就会考虑去存dist了，所以经过上面所说我自己总结结果如下")])]),e._v(" "),_("blockquote",[_("p",[e._v("大一点的文件会缓存在dist里面，因为内存也是有限的，磁盘的空间更大"),_("br"),e._v("\n小一点文件js,图片存的是memory"),_("br"),e._v("\ncss文件一般存在dist"),_("br"),e._v("\n特殊情况memory大小是有限制的，浏览器也会根据自己的内置算法，把一部分js文件存到dist里面")])])])}),[],!1,null,null,null);v.default=a.exports}}]);