(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{420:function(t,e,s){"use strict";s.r(e);var a=s(42),r=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"重排重绘为什么会影响渲染-如何避免"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重排重绘为什么会影响渲染-如何避免"}},[t._v("#")]),t._v(" 重排重绘为什么会影响渲染，如何避免")]),t._v(" "),s("p",[t._v("重排和重绘为什么会影响渲染，哪个影响更大，如何避免是经常被问到的一道题目")]),t._v(" "),s("h2",{attrs:{id:"重绘"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重绘"}},[t._v("#")]),t._v(" 重绘")]),t._v(" "),s("p",[t._v("重绘指的是不影响界面布局的操作，比如更改颜色，那么根据上面的渲染讲解我们知道，重绘之后我们只需要在重复进行一下样式计算，就可以直接渲染了，对浏览器渲染的影响相对较小")]),t._v(" "),s("h2",{attrs:{id:"重排"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#重排"}},[t._v("#")]),t._v(" 重排")]),t._v(" "),s("p",[t._v("重排指的是影响界面布局的操作，比如改变宽高，隐藏节点等。对于重排就不是一个重新计算样式那么简单了，因为改变了布局，根据上面的渲染流程来看涉及到的阶段有样式计算，布局树重新生成，分层树重新生成，所以重排对浏览器的渲染影响是比较高的")]),t._v(" "),s("h2",{attrs:{id:"避免方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#避免方法"}},[t._v("#")]),t._v(" 避免方法")]),t._v(" "),s("p",[s("code",[t._v("js")]),t._v(" 尽量减少对样式的操作，能用 "),s("code",[t._v("css")]),t._v(" 完成的就用 "),s("code",[t._v("css")]),s("br"),t._v("\n对 "),s("code",[t._v("dom")]),t._v(" 操作尽量少，能用 "),s("code",[t._v("createDocumentFragment")]),t._v(" 的地方尽量用"),s("br"),t._v("\n如果必须要用 "),s("code",[t._v("js")]),t._v(" 操作样式，能合并尽量合并不要分多次操作"),s("br"),t._v(" "),s("code",[t._v("resize")]),t._v(" 事件 最好加上防抖，能尽量少触发就少触发"),s("br"),t._v("\n加载图片的时候，提前写好宽高")])])}),[],!1,null,null,null);e.default=r.exports}}]);